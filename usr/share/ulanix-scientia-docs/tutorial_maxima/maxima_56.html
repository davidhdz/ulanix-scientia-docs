<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on mayo, 2 2007 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 56. linearalgebra</title>

<meta name="description" content="Manual de Maxima: 56. linearalgebra">
<meta name="keywords" content="Manual de Maxima: 56. linearalgebra">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,180); /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    font-family: "Lucida Console", monospace
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}
-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="linearalgebra"></a>
<a name="SEC202"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_55.html#SEC201" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC203" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_55.html#SEC200" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_57.html#SEC205" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 56. linearalgebra </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC203">56.1 Introducci&oacute;n a linearalgebra</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC204">56.2 Definiciones para linearalgebra</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-linearalgebra"></a>
<a name="SEC203"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC202" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC204" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC202" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC202" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_57.html#SEC205" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 56.1 Introducci&oacute;n a linearalgebra </h2>

<p>El paquete <code>linearalgebra</code> contiene una bater&iacute;a de
funciones para &aacute;lgebra lineal.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) M : matrix ([1, 2], [1, 2]);
                            [ 1  2 ]
(%o1)                       [      ]
                            [ 1  2 ]
(%i2) nullspace (M);
                               [  1  ]
                               [     ]
(%o2)                     span([   1 ])
                               [ - - ]
                               [   2 ]
(%i3) columnspace (M);
                                [ 1 ]
(%o3)                      span([   ])
                                [ 1 ]
(%i4) ptriangularize (M - z*ident(2), z);
                         [ 1   2 - z   ]
(%o4)                    [             ]
                         [           2 ]
                         [ 0  3 z - z  ]
(%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                     [ 1 - z    2      3   ]
                     [                     ]
(%o5)                [   4    5 - z    6   ]
                     [                     ]
                     [   7      8    9 - z ]
(%i6) MM : ptriangularize (M, z);
              [ 4  5 - z            6            ]
              [                                  ]
              [                2                 ]
              [     66        z    102 z   132   ]
              [ 0   --      - -- + ----- + ---   ]
(%o6)         [     49        7     49     49    ]
              [                                  ]
              [               3        2         ]
              [           49 z    245 z    147 z ]
              [ 0    0    ----- - ------ - ----- ]
              [            264      88      44   ]
(%i7) algebraic : true;
(%o7)                         true
(%i8) tellrat (MM [3, 3]);
                         3       2
(%o8)                  [z  - 15 z  - 18 z]
(%i9) MM : ratsimp (MM);
               [ 4  5 - z           6           ]
               [                                ]
               [                2               ]
(%o9)          [     66      7 z  - 102 z - 132 ]
               [ 0   --    - ------------------ ]
               [     49              49         ]
               [                                ]
               [ 0    0             0           ]
(%i10) nullspace (MM);
                        [        1         ]
                        [                  ]
                        [   2              ]
                        [  z  - 14 z - 16  ]
                        [  --------------  ]
(%o10)             span([        8         ])
                        [                  ]
                        [    2             ]
                        [   z  - 18 z - 12 ]
                        [ - -------------- ]
                        [         12       ]
(%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]);
                       [ 1   2   3   4  ]
                       [                ]
                       [ 5   6   7   8  ]
(%o11)                 [                ]
                       [ 9   10  11  12 ]
                       [                ]
                       [ 13  14  15  16 ]
(%i12) columnspace (M);
                           [ 1  ]  [ 2  ]
                           [    ]  [    ]
                           [ 5  ]  [ 6  ]
(%o12)                span([    ], [    ])
                           [ 9  ]  [ 10 ]
                           [    ]  [    ]
                           [ 13 ]  [ 14 ]
(%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                           [ 0 ]  [  1  ]
                           [   ]  [     ]
                           [ 1 ]  [  0  ]
(%o13)                span([   ], [     ])
                           [ 2 ]  [ - 1 ]
                           [   ]  [     ]
                           [ 3 ]  [ - 2 ]
</pre></td></tr></table>
<hr size="6">
<a name="Definiciones-para-linearalgebra"></a>
<a name="SEC204"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC203" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_57.html#SEC205" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC202" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC202" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_57.html#SEC205" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 56.2 Definiciones para linearalgebra </h2>

<dl>
<dt><u>Funci&oacute;n:</u> <b>addmatrices</b><i> (<var>f</var>, <var>M_1</var>, ..., <var>M_n</var>)</i>
<a name="IDX1786"></a>
</dt>
<dd><p>Utiliza la funci&oacute;n <var>f</var> como una funci&oacute;n aditiva, devolviendo la
suma de las matrices <var>M_1</var>, ..., <var>M_n</var>. La funci&oacute;n <var>f</var> debe
ser tal que acepte un n&uacute;mero arbitrario de argumentos; en otras palabras,
ser&aacute; una funci&oacute;n n-aria de Maxima.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) m1 : matrix([1,2],[3,4])$
(%i2) m2 : matrix([7,8],[9,10])$
(%i3) addmatrices('max,m1,m2);
(%o3) matrix([7,8],[9,10])
(%i4) addmatrices('max,m1,m2,5*m1);
(%o4) matrix([7,10],[15,20])
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>blockmatrixp</b><i> (<var>M</var>)</i>
<a name="IDX1787"></a>
</dt>
<dd><p>Devuelve el valor <code>true</code> si y solo si <var>M</var> es una matriz
cuyos elementos son a su vez matrices.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>columnop</b><i> (<var>M</var>, <var>i</var>, <var>j</var>, <var>theta</var>)</i>
<a name="IDX1788"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz, devuelve la matriz que resulta de hacer la
operaci&oacute;n columna <code>C_i &lt;- C_i - <var>theta</var> * C_j</code>. Si <var>M</var>
carece de cualquiera de las filas <var>i</var> o <var>j</var>, devuelve un mensaje
de error.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>columnswap</b><i> (<var>M</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX1789"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz, intercambia las columnas <var>i</var> y <var>j</var>.
Si <var>M</var> carece de cualquiera de las filas <var>i</var> o <var>j</var>, devuelve 
un mensaje de error.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>columnspace</b><i> (<var>M</var>)</i>
<a name="IDX1790"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz, devuelve <code>span (v_1, ..., v_n)</code>, donde
el conjunto <code>{v_1, ..., v_n}</code> es la base del espacio generado por
las columnas de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>copy</b><i> (<var>e</var>)</i>
<a name="IDX1791"></a>
</dt>
<dd><p>Devuelve una copia de la expresi&oacute;n <var>e</var> de Maxima. Aunque <var>e</var>
puede ser cualquier expresi&oacute;n de Maxima, la funci&oacute;n <code>copy</code> es
especialmente &uacute;til cuando <var>e</var> es una lista o una matriz. 
Consid&eacute;rese el siguiente ejemplo:
m : [1,[2,3]]$
mm : m$
mm[2][1] : x$
m;
mm;
</p><table><tr><td>&nbsp;</td><td><pre class="example">(%i1) m : [1,[2,3]]$
(%i2) mm : m$
(%i3) mm[2][1] : x$
(%i4) m;
(%o4)                      [1,[x,3]]
(%i5) mm;
(%o5)                      [1,[x,3]]
</pre></td></tr></table><p>Veamos el mismo ejemplo siendo ahora <var>mm</var> una copia de <var>m</var>
m : [1,[2,3]]$
mm : copy(m)$
mm[2][1] : x$
m;
mm;
</p><table><tr><td>&nbsp;</td><td><pre class="example">(%i6) m : [1,[2,3]]$
(%i7) mm : copy(m)$
(%i8) mm[2][1] : x$
(%i9) m;
(%o9)                     [1,[2,3]]
(%i10) mm;
(%o10)                    [1,[x,3]]
</pre></td></tr></table><p>En esta ocasi&oacute;n, la asignaci&oacute;n a <var>mm</var> no cambia el valor de <var>m</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>cholesky</b><i> (<var>M</var>)</i>
<a name="IDX1792"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>cholesky</b><i> (<var>M</var>, <var>field</var>)</i>
<a name="IDX1793"></a>
</dt>
<dd><p>Devuelve la factorizaci&oacute;n de Cholesky de la matriz autoadjunta 
(o herm&iacute;tica) <var>M</var>. El valor por defecto del segundo argumento
es <var>generalring</var>. Para una descripci&oacute;n de los posibles valores para
<var>field</var>, v&eacute;ase <code>lu_factor</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ctranspose</b><i> (<var>M</var>)</i>
<a name="IDX1794"></a>
</dt>
<dd><p>Devuelve la transpuesta compleja conjugada de la matriz <var>M</var>. La funci&oacute;n
<code>ctranspose</code> utiliza <code>matrix_element_transpose</code> para transponer
cada elemento de la matriz.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>diag_matrix</b><i> (<var>d_1</var>, <var>d_2</var>,...,<var>d_n</var>)</i>
<a name="IDX1795"></a>
</dt>
<dd><p>Devuelve una matriz diagonal con los elementos de la diagonal iguales a
<var>d_1</var>, <var>d_2</var>,...,<var>d_n</var>; cuando &eacute;stos son matrices, los
elementos nulos de la matriz devuelta son matrices nulas de tama&ntilde;o 
apropiado. Por ejemplo:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                            [ [ 1  0 ]  [ 0  0 ] ]
                            [ [      ]  [      ] ]
                            [ [ 0  2 ]  [ 0  0 ] ]
(%o1)                       [                    ]
                            [ [ 0  0 ]  [ 3  0 ] ]
                            [ [      ]  [      ] ]
                            [ [ 0  0 ]  [ 0  4 ] ]
(%i2) diag_matrix(p,q);

                                   [ p  0 ]
(%o2)                              [      ]
                                   [ 0  q ]
</pre></td></tr></table></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>dotproduct</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1796"></a>
</dt>
<dd><p>Devuelve el producto escalar de los vectores <var>u</var> y <var>v</var>. Equivale
a <code>conjugate (transpose (<var>u</var>)) . <var>v</var></code>. Los argumentos <var>u</var> y <var>v</var>
deben ser vectores columna.
</p>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>eigens_by_jacobi</b><i> (<var>A</var>)</i>
<a name="IDX1797"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>eigens_by_jacobi</b><i> (<var>A</var>, <var>field_type</var>)</i>
<a name="IDX1798"></a>
</dt>
<dd><p>Calcula los valores y vectores propios de <var>A</var> por el m&eacute;todo de
las rotaciones de Jacobi. <var>A</var> debe ser una matriz sim&eacute;trica
(aunque no necesariamente definida o semidefinida positiva).
El argumento <var>field_type</var> indica el tipo num&eacute;rico sobre el
que se realizan los c&aacute;lculos, que puede ser tanto <code>floatfield</code>
como <code>bigfloatfield</code>. En caso de que no se especifique <var>field_type</var>,
su valor por defecto ser&aacute; <code>floatfield</code>.
</p>
<p>Los elementos de <var>A</var> deben ser n&uacute;meros o expresiones reducibles
a n&uacute;meros mediante la ejecuci&oacute;n de <code>float</code> o <code>bfloat</code>,
seg&uacute;n sea el valor de <var>field_type</var>.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);
                     [     1         1    ]
                     [  -------   ------- ]
                     [  sqrt(2)   sqrt(2) ]
(%o1)                [                    ]
                     [      1        1    ]
                     [ - -------  ------- ]
                     [   sqrt(2)  sqrt(2) ]
(%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                      [ sqrt(3)     0    ]
(%o2)                 [                  ]
                      [    0     sqrt(5) ]
(%i3) M : S . L . transpose (S);
            [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
            [ ------- + -------  ------- - ------- ]
            [    2         2        2         2    ]
(%o3)       [                                      ]
            [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
            [ ------- - -------  ------- + ------- ]
            [    2         2        2         2    ]
(%i4) eigens_by_jacobi (M);
The largest percent change was 0.1454972243679
The largest percent change was 0.0
number of sweeps: 2
number of rotations: 1
(%o4) [[1.732050807568877, 2.23606797749979], 
                        [  0.70710678118655   0.70710678118655 ]
                        [                                      ]]
                        [ - 0.70710678118655  0.70710678118655 ]
(%i5) float ([[sqrt(3), sqrt(5)], S]);
(%o5) [[1.732050807568877, 2.23606797749979], 
                        [  0.70710678118655   0.70710678118655 ]
                        [                                      ]]
                        [ - 0.70710678118655  0.70710678118655 ]
(%i6) eigens_by_jacobi (M, bigfloatfield);
The largest percent change was 1.454972243679028b-1
The largest percent change was 0.0b0
number of sweeps: 2
number of rotations: 1
(%o6) [[1.732050807568877b0, 2.23606797749979b0], 
                [  7.071067811865475b-1   7.071067811865475b-1 ]
                [                                              ]]
                [ - 7.071067811865475b-1  7.071067811865475b-1 ]
</pre></td></tr></table>
</dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>get_lu_factors</b><i> (<var>x</var>) </i>
<a name="IDX1799"></a>
</dt>
<dd><p>Cuando <code><var>x</var> = lu_factor (<var>A</var>)</code>, entonces <code>get_lu_factors</code>
devuelve una lista de la forma <code>[P, L, U]</code>, donde <var>P</var> es una matriz
permutaci&oacute;n, <var>L</var> es triangular inferior con unos en la diagonal y <var>U</var>
es triangular superior, verific&aacute;ndose que <code><var>A</var> = <var>P</var> <var>L</var> <var>U</var></code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>hankel</b><i> (<var>col</var>)</i>
<a name="IDX1800"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>hankel</b><i> (<var>col</var>, <var>row</var>)</i>
<a name="IDX1801"></a>
</dt>
<dd><p>Devuelve la matriz de Hankel <var>H</var>. La primera columna de <var>H</var> coincide
con <var>col</var>, excepto en el primer elemento, la &uacute;ltima fila de <var>H</var> es
<var>row</var>. El valor por defecto para <var>row</var> es el vector nulo con igual
n&uacute;mero de elementos que <var>col</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>hessian</b><i> (<var>f</var>,<var>vars</var>)</i>
<a name="IDX1802"></a>
</dt>
<dd><p>Devuelve la matriz hessiana de <var>f</var> con respecto de las variables de
la lista <var>vars</var>. El elemento <var>i</var>,<var>j</var>-&eacute;simo de la matriz
hessiana es <var>diff(f vars[i],1,vars[j],1)</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>hilbert_matrix</b><i> (<var>n</var>)</i>
<a name="IDX1803"></a>
</dt>
<dd><p>Devuelve la matriz de Hilbert <var>n</var> por <var>n</var>. Si <var>n</var> no es
un entero positivo, emite un mensaje de error.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>identfor</b><i> (<var>M</var>)</i>
<a name="IDX1804"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>identfor</b><i> (<var>M</var>, <var>fld</var>)</i>
<a name="IDX1805"></a>
</dt>
<dd><p>Devuelve una matriz identidad con la misma forma que la matriz
<var>M</var>. Los elementos de la diagonal de la matriz identidad son
la identidad multiplicativa del campo <var>fld</var>; el valor por
defecto para <var>fld</var> es <var>generalring</var>.
</p>
<p>El primer argumento <var>M</var> debe ser una matriz cuadrada o no ser
matriz en absoluto. Si <var>M</var> es una matriz, sus elementos pueden
ser matrices cuadradas. La matriz puede tener bloques a cualquier nivel
finito de profundidad.
</p>
<p>V&eacute;ase tambi&eacute;n <code>zerofor</code>
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>invert_by_lu</b><i> (<var>M</var>, <var>(rng generalring)</var>)</i>
<a name="IDX1806"></a>
</dt>
<dd><p>Invierte la matriz <var>M</var> mediante la factorizaci&oacute;n LU, la cual
se hace utilizando el anillo <var>rng</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>kronecker_product</b><i> (<var>A</var>, <var>B</var>)</i>
<a name="IDX1807"></a>
</dt>
<dd><p>Devuelve el producto de Kroneckerde las matrices <var>A</var> y <var>B</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>listp</b><i> (<var>e</var>, <var>p</var>)</i>
<a name="IDX1808"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>listp</b><i> (<var>e</var>)</i>
<a name="IDX1809"></a>
</dt>
<dd><p>Dado el argumento opcional <var>p</var>, devuelve <code>true</code> si <var>e</var> es
una lista de Maxima y <var>p</var> toma el valor <code>true</code> al aplicarlo
a cada elemento de la lista. Si a <code>listp</code> no se le suministra el
argumento opcional, devuelve <code>true</code> si <var>e</var> es una lista de Maxima.
En cualquier otro caso, el resultado es <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>locate_matrix_entry</b><i> (<var>M</var>, <var>r_1</var>, <var>c_1</var>, <var>r_2</var>, <var>c_2</var>, <var>f</var>, <var>rel</var>)</i>
<a name="IDX1810"></a>
</dt>
<dd><p>El primer argumento debe ser una matriz, mientras que los argumentos
desde <var>r_1</var> hasta <var>c_2</var> determinan la submatriz de <var>M</var> tomando
las filas desde <var>r_1</var> hasta <var>r_2</var> y las columnas desde <var>c_1</var>
hasta <var>c_2</var>.
</p>
<p>La funci&oacute;n <code>locate_matrix_entry</code> busca en la submatriz de <var>M</var>
un elemento que satisfaga cierta propiedad. hay tres posibilidades:
</p>
<p>(1) <code><var>rel</var> = 'bool</code> y <var>f</var> es un predicado: 
</p>
<p>Rastrea la submatriz de izquierda a derecha y de arriba hacia abajo,
devolviendo el &iacute;ndice del primer elemento que 
satisface el predicado <var>f</var>; si ning&uacute;n elemento lo satisface,
el resultado es <code>false</code>.
</p>
<p>(2) <code><var>rel</var> = 'max</code> y <var>f</var> una funci&oacute;n real:
</p>
<p>Rastrea la submatriz buscando el elemento que maximice <var>f</var>,
devolviendo el &iacute;ndice correspondiente.
</p>
<p>(3) <code><var>rel</var> = 'min</code> y <var>f</var> una funci&oacute;n real:
</p>
<p>Rastrea la submatriz buscando el elemento que minimice <var>f</var>,
devolviendo el &iacute;ndice correspondiente.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lu_backsub</b><i> (<var>M</var>, <var>b</var>)</i>
<a name="IDX1811"></a>
</dt>
<dd><p>Si <code><var>M</var> = lu_factor (<var>A</var>, <var>field</var>)</code>, entonces
<code>lu_backsub (<var>M</var>, <var>b</var>)</code> resuelve el sistema de ecuaciones
lineales <code><var>A</var> <var>x</var> = <var>b</var></code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lu_factor</b><i> (<var>M</var>, <var>field</var>)</i>
<a name="IDX1812"></a>
</dt>
<dd><p>Devuelve una lista de la forma <code>[<var>LU</var>, <var>perm</var>, <var>fld</var>]</code>,
o <code>[<var>LU</var>, <var>perm</var>, <var>fld</var>, <var>lower-cnd</var> <var>upper-cnd</var>]</code>, donde
</p>

<ul>
<li>
La matriz <var>LU</var> contiene la factorizaci&oacute;n de <var>M</var> de forma empaquetada, lo
que significa tres cosas. En primer lugar, que las filas de <var>LU</var> est&aacute;n permutadas de
acuerdo con la lista <var>perm</var>; por ejemplo, si <var>perm</var> es la lista <code>[3,2,1]</code>,
la primera fila de la factorizaci&oacute;n <var>LU</var> es la tercera fila de la matriz <var>LU</var>.
En segundo lugar, el factor triangular inferior de <var>M</var> es la parte triangular inferior
de <var>LU</var> con los elementos de la diagonal sustituidos por unos. Por &uacute;ltimo, el factor
triangular superior de <var>M</var> es la parte triangular superior de <var>LU</var>.

</li><li>
Si el campo es <code>floatfield</code> o <code>complexfield</code>, los n&uacute;meros <var>lower-cnd</var> y
<var>upper-cnd</var> son las cotas inferior y superior del n&uacute;mero de condici&oacute;n de la norma
infinita de <var>M</var>. El n&uacute;mero de condici&oacute;n no se puede estimar para todos los campos,
en cuyo caso <code>lu_factor</code> devuelve una lista de dos elementos. Tanto la cota inferior
como la superior pueden diferir de sus valores verdaderos. V&eacute;ase tambi&eacute;n <code>mat_cond</code>.

</li></ul>

<p>El argumento <var>M</var> debe ser una matriz cuadrada.
</p>
<p>El argumento opcional <var>fld</var> debe ser un s&iacute;mbolo que determine un anillo o
un campo. Los anillos y campos predefinidos son:
</p>
<ol>
<li>
<code>generalring</code> - el anillo de las expresiones de Maxima

</li><li>
<code>floatfield</code> - el campo de los n&uacute;meros decimales en coma flotante de doble precisi&oacute;n

</li><li>
<code>complexfield</code> - el campo de los n&uacute;meros complejos decimales en coma flotante de doble precisi&oacute;n

</li><li>
<code>crering</code>  - el anillo de las expresiones can&oacute;nicas racionales (<i>Canonical Rational Expression</i> o CRE) de Maxima

</li><li>
<code>rationalfield</code> - el campo de los n&uacute;meros racionales

</li><li>
<code>runningerror</code> - controla los errores de redondeo de las operaciones en coma flotante

</li><li>
<code>noncommutingring</code> - el anillo de las expresiones de Maxima en las que el producto es el operador no conmutativo &quot;.&quot;

</li></ol>

<p>Si el campo es <code>floatfield</code>, <code>complexfield</code> o <code>runningerror</code>,
el algoritmo utiliza pivoteo parcial; para los dem&aacute;s campos, las filas se cambian 
cuando se necesita evitar pivotes nulos.
</p>
<p>La suma aritm&eacute;tica en coma flotante no es asociativa, por lo que el
significado de 'campo' no coincide exactamente con su definici&oacute;n matem&aacute;tica.
</p>
<p>Un elemento del campo <code>runningerror</code> consiste en una lista de Maxima
de la forma <code>[x,n]</code>, donde <var>x</var> es un n&uacute;mero decimal en coma flotante 
y <code>n</code> un enetro. La diferencia relativa entre el valor real de <code>x</code> y 
<code>x</code> est&aacute; aproximadamente acotado por el valor epsilon de la m&aacute;quina 
multiplicado por <code>n</code>. 
</p>
<p>No es posible la definici&oacute;n de un nuevo campo por parte del usuario, a menos
que &eacute;ste tenga conocimientos de Common Lisp. Para hacerlo, el usuario debe
definir funciones para las operaciones aritm&eacute;ticas y para convertir de la
representaci&oacute;n del campo a Maxima y al rev&eacute;s. Adem&aacute;s, en los campos ordenados,
donde se hace uso del pivoteo parcial, el usuario debe definir funciones para el 
m&oacute;dulo y para comparar n&uacute;meros del campo. Despu&eacute;s de lo anterior, tan solo queda
definir una estructura Common Lisp <code>mring</code>. El fichero <code>mring</code> tiene
muchos ejemplos.
</p>
<p>Para calcular la factorizaci&oacute;n, la primera tarea consiste en convertir cada elemento
de la matriz a un elemento del campo especificado. Si la conversi&oacute;n no es posible,
la factorizaci&oacute;n se detiene con un mensaje de error. Los elementos del campo
no necesitan ser expresiones de Maxima; por ejemplo, los elementos de <code>complexfield</code>
son n&uacute;meros complejos de Common Lisp. Tras la factorizaci&oacute;n, los elementos de la
matriz deben convertirse nuevamente a expresiones de Maxima.
</p>
<p>V&eacute;ase tambi&eacute;n  <code>get_lu_factors</code>.
</p>

<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) w[i,j] := random (1.0) + %i * random (1.0);
(%o1)          w     := random(1.) + %i random(1.)
                i, j
(%i2) showtime : true$
Evaluation took 0.00 seconds (0.00 elapsed)
(%i3) M : genmatrix (w, 100, 100)$
Evaluation took 7.40 seconds (8.23 elapsed)
(%i4) lu_factor (M, complexfield)$
Evaluation took 28.71 seconds (35.00 elapsed)
(%i5) lu_factor (M, generalring)$
Evaluation took 109.24 seconds (152.10 elapsed)
(%i6) showtime : false$

(%i7) M : matrix ([1 - z, 3], [3, 8 - z]); 
                        [ 1 - z    3   ]
(%o7)                   [              ]
                        [   3    8 - z ]
(%i8) lu_factor (M, generalring);
          [ 1 - z         3        ]
          [                        ]
(%o8)    [[   3            9       ], [1, 2], generalring]
          [ -----  - z - ----- + 8 ]
          [ 1 - z        1 - z     ]
(%i9) get_lu_factors (%);
                  [   1    0 ]  [ 1 - z         3        ]
        [ 1  0 ]  [          ]  [                        ]
(%o9)  [[      ], [   3      ], [                9       ]]
        [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                  [ 1 - z    ]  [              1 - z     ]
(%i10) %[1] . %[2] . %[3];
                        [ 1 - z    3   ]
(%o10)                  [              ]
                        [   3    8 - z ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>mat_cond</b><i> (<var>M</var>, 1)</i>
<a name="IDX1813"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>mat_cond</b><i> (<var>M</var>, inf)</i>
<a name="IDX1814"></a>
</dt>
<dd><p>Devuelve el n&uacute;mero de condici&oacute;n de la <var>p</var>-norma de la matriz
<var>M</var>. Los valores admisibles para  <var>p</var> son 1 y <var>inf</var>. Esta
funci&oacute;n utiliza la factorizaci&oacute;n LU para invertir la matriz <var>M</var>,
por lo que el tiempo de ejecuci&oacute;n de <code>mat_cond</code> es proporcional al
cubo del tama&ntilde;o de la matriz; <code>lu_factor</code> determina las cotas inferior
y superior para el n&uacute;mero de condici&oacute;n de la norma infinita en un tiempo
proporcional al cuadrado del tama&ntilde;o de la matriz.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>mat_norm</b><i> (<var>M</var>, 1)</i>
<a name="IDX1815"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>mat_norm</b><i> (<var>M</var>, inf)</i>
<a name="IDX1816"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>mat_norm</b><i> (<var>M</var>, frobenius)</i>
<a name="IDX1817"></a>
</dt>
<dd><p>Devuelve la <var>p</var>-norma de la matriz <var>M</var>. Los valores admisibles
para <var>p</var> son 1, <code>inf</code> y <code>frobenius</code> (la norma matricial de Frobenius).
La matriz <var>M</var> no debe contener bloques.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>matrixp</b><i> (<var>e</var>, <var>p</var>)</i>
<a name="IDX1818"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>matrixp</b><i> (<var>e</var>)</i>
<a name="IDX1819"></a>
</dt>
<dd><p>Dado el argumento opcional <var>p</var>, devuelve <code>true</code> si <var>e</var> es
una matriz y <var>p</var> toma el valor <code>true</code> al aplicarlo
a cada elemento de la matriz. Si a <code>matrixp</code> no se le suministra el
argumento opcional, devuelve <code>true</code> si <var>e</var> es una matriz.
En cualquier otro caso, el resultado es <code>false</code>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>blockmatrixp</code>
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>matrix_size</b><i> (<var>M</var>)</i>
<a name="IDX1820"></a>
</dt>
<dd><p>Devuelve una lista con el n&uacute;mero de filas y columnas de la matriz <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>mat_fullunblocker</b><i> (<var>M</var>)</i>
<a name="IDX1821"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz de bloques, transforma la matriz llevando todos
los elementos de los bloques al primer nivel. Si <var>M</var> es una matriz,
devuelve <var>M</var>; en cualquier otro caso, env&iacute;a un mensaje de error.  
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>mat_trace</b><i> (<var>M</var>)</i>
<a name="IDX1822"></a>
</dt>
<dd><p>Calcula la traza de la matriz <var>M</var>. Si <var>M</var> no es una matriz, devuelve
una forma nominal. Si <var>M</var> es una matriz de bloques, <code>mat_trace(M)</code>
calcula el mismo valor que <code>mat_trace(mat_unblocker(m))</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>mat_unblocker</b><i> (<var>M</var>)</i>
<a name="IDX1823"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz de bloques, deshace los bloques de un nivel. Si <var>M</var>
es una matriz, <code>mat_unblocker (M)</code> devuelve <var>M</var>; en cualquier otro caso, 
env&iacute;a un mensaje de error.
</p>
<p>Si todos los elementos de <var>M</var> son matrices, <code>mat_unblocker (M)</code> devuelve
una matriz sin bloques, pero si los elementos de <var>M</var> son a su vez matrices de
bloques, <code>mat_unblocker (M)</code> devuelve una matriz con el nivel de bloques
disminuido en uno.
</p>
<p>En caso de trabajar con matrices de bloques, quiz&aacute;s sea conveniente darle a
<code>matrix_element_mult</code> el valor <code>&quot;.&quot;</code> y a <code>matrix_element_transpose</code>
el valor <code>'transpose</code>. V&eacute;ase tambi&eacute;n <code>mat_fullunblocker</code>.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) A : matrix ([1, 2], [3, 4]);
                            [ 1  2 ]
(%o1)                       [      ]
                            [ 3  4 ]
(%i2) B : matrix ([7, 8], [9, 10]);
                            [ 7  8  ]
(%o2)                       [       ]
                            [ 9  10 ]
(%i3) matrix ([A, B]);
                     [ [ 1  2 ]  [ 7  8  ] ]
(%o3)                [ [      ]  [       ] ]
                     [ [ 3  4 ]  [ 9  10 ] ]
(%i4) mat_unblocker (%);
                         [ 1  2  7  8  ]
(%o4)                    [             ]
                         [ 3  4  9  10 ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>nonnegintegerp</b><i> (<var>n</var>)</i>
<a name="IDX1824"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y solo si <code><var>n</var> &gt;= 0</code>, siendo <var>n</var> un entero.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>nullspace</b><i> (<var>M</var>)</i>
<a name="IDX1825"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz, devuelve <code>span (v_1, ..., v_n)</code>, siendo 
<code>{v_1, ..., v_n}</code> la base del espacio nulo de <var>M</var>. Si el 
espacio nulo contiene un &uacute;nico elemento, devuelve <code>span ()</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>nullity</b><i> (<var>M</var>)</i>
<a name="IDX1826"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz, devuelve la dimensi&oacute;n del espacio nulo de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>orthogonal_complement</b><i> (<var>v_1</var>, ..., <var>v_n</var>)</i>
<a name="IDX1827"></a>
</dt>
<dd><p>Devuelve <code>span (u_1, ..., u_m)</code>, siendo <code>{u_1, ..., u_m}</code> la base
del complemento ortogonal del conjunto <code>(v_1, ..., v_n)</code>, cuyos elementos
deben ser vectores columna.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>polynomialp</b><i> (<var>p</var>, <var>L</var>, <var>coeffp</var>, <var>exponp</var>)</i>
<a name="IDX1828"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>polynomialp</b><i> (<var>p</var>, <var>L</var>, <var>coeffp</var>)</i>
<a name="IDX1829"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>polynomialp</b><i> (<var>p</var>, <var>L</var>)</i>
<a name="IDX1830"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>p</var> es un polinomio cuyas variables son las
de la lista <var>L</var>, el predicado <var>coeffp</var> toma el valor <code>true</code> al
aplicarlo a cada coeficiente y el predicado <var>exponp</var> tambi&eacute;n alcanza el
valor <code>true</code> al ser aplicado a los exponentes de las variables listadas en
<var>L</var>. En caso de necesitar que <var>exponp</var> no sea un predicado por defecto,
se deber&aacute; especificar tambi&eacute;n el predicado <var>coeffp</var>, aunque aqu&iacute;
se desee su comportamiento por defecto.
</p>
<p><code>polynomialp (<var>p</var>, <var>L</var>, <var>coeffp</var>)</code> equivale a
<code>polynomialp (<var>p</var>, <var>L</var>, <var>coeffp</var>, 'nonnegintegerp)</code>.
</p>
<p><code>polynomialp (<var>p</var>, <var>L</var>)</code> equivale a
<code>polynomialp (<var>p</var>, L<var>,</var> 'constantp, 'nonnegintegerp)</code>.
</p>
<p>No es necesario expandir el polinomio:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) polynomialp ((x + 1)*(x + 2), [x]);
(%o1)                         true
(%i2) polynomialp ((x + 1)*(x + 2)^a, [x]);
(%o2)                         false
</pre></td></tr></table>
<p>Un ejemplo utilizando valores distintos a los utilizados por defecto en 
<var>coeffp</var> y en <var>exponp</var>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
(%o1)                         true
(%i2) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp, numberp);
(%o2)                         true
</pre></td></tr></table>
<p>Polinomios con dos variables:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) polynomialp (x^2 + 5*x*y + y^2, [x]);
(%o1)                         false
(%i2) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
(%o2)                         true
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>polytocompanion</b><i> (<var>p</var>, <var>x</var>)</i>
<a name="IDX1831"></a>
</dt>
<dd><p>Si <var>p</var> es un polinomio en <var>x</var>, devuelve la matriz compa&ntilde;era de <var>p</var>. Para
un polinomio m&oacute;nico <var>p</var> de grado <var>n</var> se tiene
<code><var>p</var> = (-1)^<var>n</var> charpoly (polytocompanion (<var>p</var>, <var>x</var>))</code>.
</p>
<p>Si <var>p</var> no es un polinomio en  <var>x</var>, se devuelve un mensaje de error.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ptriangularize</b><i> (<var>M</var>, <var>v</var>)</i>
<a name="IDX1832"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz en la que sus elementos son polinomios en <var>v</var>,
devuelve una matriz <var>M2</var> tal que
</p>
<ol>
<li>
<var>M2</var> es triangular superior,

</li><li>
<code><var>M2</var> = <var>E_n</var> ... <var>E_1</var> <var>M</var></code>, donde <var>E_1</var>, ...,
<var>E_n</var> son matrices elementales cuyos elementos son polinomios en <var>v</var>,

</li><li>
<code>|det (<var>M</var>)| = |det (<var>M2</var>)|</code>,
</li></ol>

<p>Nota: esta funci&oacute;n no comprueba si los elementos de la matriz son
polinomios en <var>v</var>.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>rowop</b><i> (<var>M</var>, <var>i</var>, <var>j</var>, <var>theta</var>)</i>
<a name="IDX1833"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz, devuelve la matriz que resulta de relizar la
transformaci&oacute;n <code>R_i &lt;- R_i - theta * R_j</code> con las filas <code>R_i</code> y 
<code>R_j</code>. Si <var>M</var> no tiene estas filas, devuelve un mensaje de error.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>rank</b><i> (<var>M</var>)</i>
<a name="IDX1834"></a>
</dt>
<dd><p>Calcula el rango de la matriz <var>M</var>. El rango es la dimensi&oacute;n del 
espacio columna. Ejemplo:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(%i1) rank(matrix([1,2],[2,4]));
(%o1)                                  1
(%i2) rank(matrix([1,b],[c,d]));
Proviso:  {d - b c # 0}
(%o2)                                  2
</pre></td></tr></table>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>rowswap</b><i> (<var>M</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX1835"></a>
</dt>
<dd><p>Si <var>M</var> es una matriz, intercambia las filas  <var>i</var> y <var>j</var>. Si <var>M</var>
carece de estas filas, devuelve un mensaje de error.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>toeplitz</b><i> (<var>col</var>)</i>
<a name="IDX1836"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>toeplitz</b><i> (<var>col</var>, <var>row</var>)</i>
<a name="IDX1837"></a>
</dt>
<dd><p>Devuelve una  matriz de Toeplitz <var>T</var>. La primera columna de <var>T</var> es <var>col</var>,
excepto su primer elemento. La primera fila de <var>T</var> es <var>row</var>. El valor por
defecto para <var>row</var> es el complejo conjugado de <var>col</var>. Ejemplo:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(%i1)  toeplitz([1,2,3],[x,y,z]);

                                  [ 1  y  z ]
                                  [         ]
(%o1)                             [ 2  1  y ]
                                  [         ]
                                  [ 3  2  1 ]
(%i2)  toeplitz([1,1+%i]);

                              [   1     1 - %I ]
(%o2)                         [                ]
                              [ %I + 1    1    ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>vandermonde_matrix</b><i> ([<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX1838"></a>
</dt>
<dd><p>Devuelve una matriz <var>n</var> por <var>n</var>, cuya <var>i</var>-&eacute;sima fila es
<code>[1, <var>x_i</var>, <var>x_i</var>^2, ... <var>x_i</var>^(<var>n</var>-1)]</code>. 
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>zerofor</b><i> (<var>M</var>)</i>
<a name="IDX1839"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>zerofor</b><i> (<var>M</var>, <var>fld</var>)</i>
<a name="IDX1840"></a>
</dt>
<dd><p>Devuelve la matriz nula con la misma estructura que la matriz <var>M</var>.
Cada elemento de la matriz nula es la identidad aditiva del campo <var>fld</var>;
el valor por defecto de <var>fld</var> es <var>generalring</var>.
</p>
<p>El primer argumento de <var>M</var> debe ser una matriz cuadrada o no ser matriz en
absoluto. Si <var>M</var> es una matriz, cada uno de sus elementos puede ser una 
matriz cuadrada, por lo que <var>M</var> puede ser una matriz de Maxima definida por
bloques.
</p>
<p>V&eacute;ase tambi&eacute;n <code>identfor</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>zeromatrixp</b><i> (<var>M</var>)</i>
<a name="IDX1841"></a>
</dt>
<dd><p>Si <var>M</var> no es una matriz definida por bloques, devuelve <code>true</code> si
 <code>is (equal (<var>e</var>, 0))</code> es verdadero para todo elemento <var>e</var> de
<var>M</var>. Si <var>M</var> es una matriz por bloques, devuelve <code>true</code> si
<code>zeromatrixp</code> devuelve a su vez <code>true</code> para cada elemento de <var>e</var>.
</p>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC202" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_57.html#SEC205" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>mayo, 2 2007</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
