<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on mayo, 2 2007 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 25. Matrices y &Aacute;lgebra Lineal</title>

<meta name="description" content="Manual de Maxima: 25. Matrices y &Aacute;lgebra Lineal">
<meta name="keywords" content="Manual de Maxima: 25. Matrices y &Aacute;lgebra Lineal">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,180); /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    font-family: "Lucida Console", monospace
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}
-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Matrices-y_00c1lgebra-Lineal"></a>
<a name="SEC81"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_24.html#SEC80" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC79" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 25. Matrices y &Aacute;lgebra Lineal </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC82">25.1 Introducci&oacute;n a las Matrices y al &Aacute;lgebra Lineal</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC86">25.2 Definiciones para las Matrices y el &Aacute;lgebra Lineal</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-las-Matrices-y-al_00c1lgebra-Lineal"></a>
<a name="SEC82"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC81" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC83" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.1 Introducci&oacute;n a las Matrices y al &Aacute;lgebra Lineal </h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC83">25.1.1 Operador punto</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC84">25.1.2 Vectores</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC85">25.1.3 Paquete eigen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Operador-punto"></a>
<a name="SEC83"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC82" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.1 Operador punto </h3>
<p>El operador  <code>.</code> realiza la multiplicaci&oacute;n matricial y el producto escalar.
Cuando los operandos son dos matrices columna o matrices fila <code>a</code> y <code>b</code>,
la expresi&oacute;n <code>a.b</code> es equivalente a <code>sum (a[i]*b[i], i, 1, length(a))</code>.
Si <code>a</code> y <code>b</code> no son complejos, estamos en el caso del producto escalar.
En caso de ser <code>a</code> y <code>b</code> vectores en el campo complejo, el producto 
escalar se define como <code>conjugate(a).b</code>; la funci&oacute;n <code>innerproduct</code> del
paquete <code>eigen</code> realiza el producto escalar complejo.
</p>
<p>Cuando los operandos son matrices de &iacute;ndole m&aacute;s general,
el resultado que se obtiene es el producto matricial de <code>a</code> por <code>b</code>.
El n&uacute;mero de filas de <code>b</code> debe ser igual al n&uacute;mero de columnas de <code>a</code>,
y el resultado tiene un n&uacute;mero de filas igual al de <code>a</code> y un n&uacute;mero de
columnas igual al de <code>b</code>.
</p>
<p>Al objeto de distinguir <code>.</code> como operador aritm&eacute;tico del punto decimal
de la notaci&oacute;n en coma flotante, puede ser necesario dejar espacios a ambos lados.
Por ejemplo, <code>5.e3</code> es <code>5000.0</code> pero <code>5 . e3</code> es <code>5</code> por <code>e3</code>.
</p>
<p>Hay algunas variables globales que controlan la simplificaci&oacute;n de expresiones que
contengan al operador <code>.</code>, a saber,
<code>dot</code>, <code>dot0nscsimp</code>, <code>dot0simp</code>, <code>dot1simp</code>, <code>dotassoc</code>, 
<code>dotconstrules</code>, <code>dotdistrib</code>, <code>dotexptsimp</code>, <code>dotident</code>,
y <code>dotscrules</code>.
</p>
<hr size="6">
<a name="Vectores"></a>
<a name="SEC84"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC83" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC85" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.2 Vectores </h3>
<p>El paquete <code>vect</code> define funciones para an&aacute;lisis vectorial. Para cargar el paquete en memoria se debe hacer
<code>load (&quot;vect&quot;)</code>  y con <code>demo (&quot;vect&quot;)</code> se presenta una demostraci&oacute;n sobre las funciones del paquete.
</p>
<p>El paquete de an&aacute;lisis vectorial puede combinar y simplificar expresiones
simb&oacute;licas que incluyan productos escalares y vectoriales, junto con los operadores
de gradiente, divergencia, rotacional y laplaciano. La distribuci&oacute;n de estos operadores
sobre sumas o productos se gobierna por ciertas variables, al igual que otras transformaciones,
incluida la expansi&oacute;n en componentes en cualquier sistema de coordenadas especificado. 
Tambi&eacute;n hay funciones para obtener el potencial escalar o vectorial de un campo.
</p>
<p>El paquete <code>vect</code> contiene las siguientes funciones:
<code>vectorsimp</code>, <code>scalefactors</code>,
<code>express</code>, <code>potential</code> y <code>vectorpotential</code>.
</p>
<p>Aviso: el paquete <code>vect</code> declara el operador <code>.</code> como conmutativo.
</p>
<hr size="6">
<a name="Paquete-eigen"></a>
<a name="SEC85"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC84" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC86" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 25.1.3 Paquete eigen </h3>

<p>El paquete <code>eigen</code> contiene funciones para el c&aacute;lculo 
simb&oacute;lico de valores y vectores propios. Maxima carga el paquete
autom&aacute;ticamente si se hace una llamada a cualquiera de las dos funciones
<code>eigenvalues</code> o <code>eigenvectors</code>. El paquete se puede cargar de
forma expl&iacute;cita mediante <code>load (&quot;eigen&quot;)</code>.
</p>
<p>La instrucci&oacute;n <code>demo (&quot;eigen&quot;)</code> hace una demostraci&oacute;n de las funciones de este paquete;
<code>batch (&quot;eigen&quot;)</code> realiza la misma demostraci&oacute;n pero sin pausas entre los
sucesivos c&aacute;lculos.
</p>
<p>Las funciones del paquete <code>eigen</code> son
<code>innerproduct</code>, <code>unitvector</code>, <code>columnvector</code>,
<code>gramschmidt</code>, <code>eigenvalues</code>, <code>eigenvectors</code>, <code>uniteigenvectors</code>
y <code>similaritytransform</code>.
</p>
<hr size="6">
<a name="Definiciones-para-las-Matrices-y-el_00c1lgebra-Lineal"></a>
<a name="SEC86"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC85" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.2 Definiciones para las Matrices y el &Aacute;lgebra Lineal </h2>

<dl>
<dt><u>Funci&oacute;n:</u> <b>addcol</b><i> (<var>M</var>, <var>lista_1</var>, ..., <var>lista_n</var>)</i>
<a name="IDX739"></a>
</dt>
<dd><p>A&ntilde;ade la/s columna/s dada/s por la/s lista/s (o matrices) a la matriz <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>addrow</b><i> (<var>M</var>, <var>lista_1</var>, ..., <var>lista_n</var>)</i>
<a name="IDX740"></a>
</dt>
<dd><p>A&ntilde;ade la/s fila/s dada/s por la/s lista/s (o matrices) a la matriz <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>adjoint</b><i> (<var>M</var>)</i>
<a name="IDX741"></a>
</dt>
<dd><p>Devuelve el adjunto de la matriz <var>M</var>.
La matriz adjunta es la transpuesta de la matriz de cofactores de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>augcoefmatrix</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX742"></a>
</dt>
<dd><p>Devuelve la matriz aumentada de coeficientes del sistema de ecuaciones lineales 
<var>eqn_1</var>, ..., <var>eqn_m</var> de variables <var>x_1</var>, ..., <var>x_n</var>. Se trata de la
matriz de coeficientes con una columna adicional para los t&eacute;rminos constantes de cada
ecuaci&oacute;n, es decir, aquellos t&eacute;rminos que no dependen de las variables
<var>x_1</var>, ..., <var>x_n</var>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>charpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX743"></a>
</dt>
<dd><p>Calcula el polinomio caracter&iacute;stico de la matriz <var>M</var>
respecto de la variable <var>x</var>. Esto es, 
<code>determinant (<var>M</var> - diagmatrix (length (<var>M</var>), <var>x</var>))</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>coefmatrix</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX744"></a>
</dt>
<dd><p>Devuelve la matriz de coeficientes para las variables <var>x_1</var>, ..., <var>x_n</var>
del sistema de ecuaciones lineales <var>eqn_1</var>, ..., <var>eqn_m</var>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>col</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX745"></a>
</dt>
<dd><p>Devuelve la <var>i</var>-&eacute;sima columna de la matriz <var>M</var>.
El resultado es una matriz de una sola columna.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>columnvector</b><i> (<var>L</var>)</i>
<a name="IDX746"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>covect</b><i> (<var>L</var>)</i>
<a name="IDX747"></a>
</dt>
<dd><p>Devuelve una matriz con una columna  y <code>length (<var>L</var>)</code> filas,
conteniendo los elementos de la lista <var>L</var>.
</p>
<p>La llamada <code>covect</code> es un sin&oacute;nimo de <code>columnvector</code>.
</p>
<p>Es necesario cargar la funci&oacute;n haciendo <code>load (&quot;eigen&quot;)</code>.
</p>

<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load (&quot;eigen&quot;)$
Warning - you are redefining the Macsyma function eigenvalues
Warning - you are redefining the Macsyma function eigenvectors
(%i2) columnvector ([aa, bb, cc, dd]);
                             [ aa ]
                             [    ]
                             [ bb ]
(%o2)                        [    ]
                             [ cc ]
                             [    ]
                             [ dd ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>conjugate</b><i> (<var>x</var>)</i>
<a name="IDX748"></a>
</dt>
<dd><p>Devuelve el conjugado complejo de <var>x</var>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

(%o1)                         done
(%i2) conjugate (aa + bb*%i);

(%o2)                      aa - %i bb
(%i3) conjugate (cc);

(%o3)                     conjugate(cc)
(%i4) conjugate (ii);

(%o4)                         - ii
(%i5) conjugate (xx + yy);

(%o5)             conjugate(yy) + conjugate(xx)
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>copymatrix</b><i> (<var>M</var>)</i>
<a name="IDX749"></a>
</dt>
<dd><p>Devuelve una copia de la matriz <var>M</var>. Esta es la &uacute;nica
manera de obtener una r&eacute;plica de <var>M</var> adem&aacute;s de la de
copiar elemento a elemento.
</p>
<p>N&oacute;tese que una asignaci&oacute;n de una matriz a otra, como en <code>m2: m1</code>,
no hace una copia de <code>m1</code>. Asignaciones del tipo <code>m2 [i,j]: x</code> o
<code>setelmx (x, i, j, m2</code> tambi&eacute;n modifica <code>m1 [i,j]</code>. Si se crea una copia 
con <code>copymatrix</code> y luego se hacen asignaciones se tendr&aacute; una copia separada y
modificada.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>determinant</b><i> (<var>M</var>)</i>
<a name="IDX750"></a>
</dt>
<dd><p>Calcula el determinante de  <var>M</var> por un m&eacute;todo similar al
de eliminaci&oacute;n de Gauss
</p>
<p>La forma del resultado depende del valor asignado
a <code>ratmx</code>.
</p>
<p>Existe una rutina especial para calcular determinantes de matrices con elementos dispersas, la cual
ser&aacute; invocada cuando las variables <code>ratmx</code> y <code>sparse</code> valgan ambas
<code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>detout</b>
<a name="IDX751"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>detout</code> vale <code>true</code>, el determinante de la matriz 
cuya inversa se calcula aparece como un factor fuera de la matriz.
</p>
<p>Para que esta variable surta efecto, <code>doallmxops</code> y <code>doscmxops</code> deber&iacute;an tener
el valor <code>false</code> (v&eacute;anse sus descripciones). Alternativamente, esta 
variable puede ser suministrada a <code>ev</code>.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>diagmatrix</b><i> (<var>n</var>, <var>x</var>)</i>
<a name="IDX752"></a>
</dt>
<dd><p>Devuelve una matriz diagonal de orden <var>n</var> 
con los elementos de la diagonal todos ellos iguales a <var>x</var>. La llamada
<code>diagmatrix (<var>n</var>, 1)</code> devuelve una matriz identidad
(igual que <code>ident (<var>n</var>)</code>).
</p>
<p>La variable <var>n</var> debe ser un n&uacute;mero entero, en caso contrario <code>diagmatrix</code> env&iacute;a un mensaje de error.
</p>
<p><var>x</var> puede ser cualquier tipo de expresi&oacute;n, incluso otra matriz.
Si <var>x</var> es una matriz, no se copia; todos los elementos de la diagonal son iguales a <var>x</var>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>doallmxops</b>
<a name="IDX753"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>doallmxops</code> vale <code>true</code>,
todas las operaciones relacionadas con matrices son
llevadas a cabo. Cuando es <code>false</code>, entonces las
selecciones para <code>dot</code> controlan las operaciones a ejecutar.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>domxexpt</b>
<a name="IDX754"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>domxexpt</code> vale <code>true</code>,
un exponente matricial, como <code>exp (<var>M</var>)</code> donde <var>M</var> es
una matriz, se interpreta como una matriz cuyo elemento <code>[i,j</code> es
igual a <code>exp (m[i,j])</code>. En otro caso, <code>exp (<var>M</var>)</code> se
eval&uacute;a como <code>exp (ev(<var>M</var>))</code>.
</p>
<p>La variable <code>domxexpt</code> afecta a todas las expresiones de la forma <code><var>base</var>^<var>exponente</var></code>
donde <var>base</var> es una expresi&oacute;n escalar o constante y <var>exponente</var> es una
lista o matriz.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>domxmxops</b>
<a name="IDX755"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>domxmxops</code> vale <code>true</code>, se realizan todas las operaciones entre
matrices o entre matrices y listas (pero no las operaciones 
entre matrices y escalares); si esta variable es <code>false</code> tales
operaciones no se realizan.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>domxnctimes</b>
<a name="IDX756"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>domxnctimes</code> vale <code>true</code>, se calculan los productos
no conmutativos entre matrices.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dontfactor</b>
<a name="IDX757"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>En <code>dontfactor</code> puede guardarse una lista de variables respecto de
las cuales no se realizar&aacute;n factorizaciones. Inicialmente, la lista
est&aacute; vac&iacute;a.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>doscmxops</b>
<a name="IDX758"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>doscmxops</code> vale <code>true</code>, se realizan las operaciones entre escalares y 
matrices.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>doscmxplus</b>
<a name="IDX759"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>doscmxplus</code> vale <code>true</code>, las operaciones entre
escalares y matrices dan como resultado una matriz.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dot0nscsimp</b>
<a name="IDX760"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>(Esta descripci&oacute;n no est&aacute; clara en la versi&oacute;n inglesa original.)
</p>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>dotassoc</b>
<a name="IDX761"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>dotassoc</code> vale <code>true</code>, una expresi&oacute;n como <code>(A.B).C</code> se transforma en
<code>A.(B.C)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotconstrules</b>
<a name="IDX762"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>dotconstrules</code> vale <code>true</code>, un producto no conmutativo de una
constante con otro t&eacute;rmino se transforma en un producto conmutativo.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotdistrib</b>
<a name="IDX763"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>dotdistrib</code> vale <code>true</code>, una expresi&oacute;n como <code>A.(B + C)</code> se transforma en <code>A.B + A.C</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotexptsimp</b>
<a name="IDX764"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>dotexptsimp</code> vale <code>true</code>, una expresi&oacute;n como <code>A.A</code> se transforma en <code>A^^2</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotident</b>
<a name="IDX765"></a>
</dt>
<dd><p>Valor por defecto: 1
</p>
<p>El valor de la variable <code>dotident</code> es el resultado devuelto por <code>X^^0</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotscrules</b>
<a name="IDX766"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>dotscrules</code> vale <code>true</code>, una expresi&oacute;n como <code>A.SC</code> o <code>SC.A</code> se transforma 
en <code>SC*A</code> y <code>A.(SC*B)</code> en <code>SC*(A.B)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>echelon</b><i> (<var>M</var>)</i>
<a name="IDX767"></a>
</dt>
<dd><p>Devuelve la forma escalonada de la matriz <var>M</var>, obtenida por eliminaci&oacute;n gaussiana.
La forma escalonada se calcula a partir de <var>M</var> mediante operaciones elementales con sus filas,
de tal manera que el primer elemento no nulo de cada fila en la matriz 
resultado es la unidad y que cada elemento de la columna por debajo del primer uno de cada
fila sean todos ceros.
</p>
<p>La funci&oacute;n <code>triangularize</code> tambi&eacute;n lleva a cabo la eliminaci&oacute;n gaussiana, pero no 
normaliza el primer elemento no nulo de cada fila.
</p>
<p>Otras funciones, como <code>lu_factor</code> y <code>cholesky</code>, tambi&eacute;n dan como resultados
matrices triangularizadas.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>eigenvalues</b><i> (<var>M</var>)</i>
<a name="IDX768"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>eivals</b><i> (<var>M</var>)</i>
<a name="IDX769"></a>
</dt>
<dd><p>Devuelve una lista con dos sublistas. La primera sublista la forman los
valores propios de la matriz <var>M</var> y la segunda sus multiplicidades correspondientes.
</p>
<p>El nombre <code>eivals</code> es un sin&oacute;nimo de <code>eigenvalues</code>.
</p>
<p>La funci&oacute;n <code>eigenvalues</code> llama a la funci&oacute;n <code>solve</code> para calcular las ra&iacute;ces
del polinomio caracter&iacute;stico de la matriz. En ocasiones, <code>solve</code> no
podr&aacute; encontrar dichas ra&iacute;ces, en cuyo caso otras funciones de este paquete
no trabajar&aacute;n correctamente, a excepci&oacute;n de <code>innerproduct</code>,
<code>unitvector</code>, <code>columnvector</code> y <code>gramschmidt</code>.
</p>
<p>En algunos casos los valores propios encontrados por <code>solve</code> ser&aacute;n
expresiones complicadas, las cuales se podr&aacute;n simplificar haciendo uso
de otras funciones.
</p>
<p>El paquete <code>eigen.mac</code> se carga en memoria de forma autom&aacute;tica cuando
se invocan <code>eigenvalues</code> o <code>eigenvectors</code>. Si <code>eigen.mac</code> no
est&aacute; ya cargado, <code>load (&quot;eigen&quot;)</code> lo carga. Tras la carga, todas las
funciones y variables del paquete estar&aacute;n activas.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>eigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX770"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>eivects</b><i> (<var>M</var>)</i>
<a name="IDX771"></a>
</dt>
<dd><p>Tomando la matriz <var>M</var> como argumento, devuelve una lista de listas,
la primera de las cuales es la salida de <code>eigenvalues</code> y las 
siguientes son los vectorios propios de la matriz asociados a los
valores propios correspondientes. Los vectores propios calculados son los 
vectores propios por la derecha.
</p>
<p>El nombre <code>eivects</code> es un sin&oacute;nimo de <code>eigenvectors</code>.
</p>
<p>El paquete <code>eigen.mac</code> se carga en memoria de forma autom&aacute;tica cuando
se invocan <code>eigenvalues</code> o <code>eigenvectors</code>. Si <code>eigen.mac</code> no
est&aacute; ya cargado, <code>load (&quot;eigen&quot;)</code> lo carga. Tras la carga, todas las
funciones y variables del paquete estar&aacute;n activas.
</p>
<p>Las variables que afectan a esta funci&oacute;n son: 
</p>
<p><code>nondiagonalizable</code> toma el valor <code>true</code> o <code>false</code> dependiendo
de si la matriz no es diagonalizable o diagonalizable tras la ejecuci&oacute;n de
<code>eigenvectors</code>.
</p>
<p><code>hermitianmatrix</code>, si vale <code>true</code>, entonces los vectores propios 
degenerados de la matriz herm&iacute;tica son ortogonalizados mediante el
algoritmo de Gram-Schmidt.
</p>
<p><code>knowneigvals</code>, si vale <code>true</code>, entonces el paquete <code>eigen</code> da por
sentado que los valores propios de la matriz son conocidos por el usuario y 
almacenados en la variable global <code>listeigvals</code>.  <code>listeigvals</code> deber&iacute;a
ser similar a la salida de <code>eigenvalues</code>.
</p>
<p>La funci&oacute;n <code>algsys</code> se utiliza aqu&iacute; para calcular los vectores propios. A
veces, <code>algsys</code> no podr&aacute; calcular una soluci&oacute;n. En algunos casos, ser&aacute; posible
simplificar los valores propios calcul&aacute;ndolos en primer lugar con <code>eigenvalues</code> y
luego utilizando otras funciones para simplificarlos. Tras la simplificaci&oacute;n, 
<code>eigenvectors</code> podr&aacute; ser llamada otra vez con la variable <code>knowneigvals</code>
ajustada al valor <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ematrix</b><i> (<var>m</var>, <var>n</var>, <var>x</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX772"></a>
</dt>
<dd><p>Devuelve una matriz de orden <var>m</var> por <var>n</var>, con todos sus elementos 
nulos, excepto el que ocupa la posici&oacute;n <code>[<var>i</var>, <var>j</var>]</code>, que
es igual a <var>x</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>entermatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX773"></a>
</dt>
<dd><p>Devuelve una matriz de orden <var>m</var> por <var>n</var>, cuyos elementos
son leidos de forma interactiva.
</p>
<p>Si <var>n</var> es igual a <var>m</var>, Maxima pregunta por el tipo de
matriz (diagonal, sim&eacute;trica, antisim&eacute;trica o general) y luego por
cada elemento. Cada respuesta introducida por el usuario debe terminar
con un punto y coma <code>;</code> o con un signo de d&oacute;lar <code>$</code>.
</p>
<p>Si <var>n</var> y <var>m</var> no son iguales, Maxima pregunta
por el valor de cada elemento.
</p>
<p>Los elementos de la matriz pueden ser cualquier tipo de 
expresi&oacute;n, que en todo caso ser&aacute; evaluada.
<code>entermatrix</code> eval&uacute;a sus argumentos.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matrix entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
</pre></td></tr></table>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>, <var>j_1</var>)</i>
<a name="IDX774"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>)</i>
<a name="IDX775"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>)</i>
<a name="IDX776"></a>
</dt>
<dd><p>Devuelve una matriz generada a partir de <var>a</var>, siendo <code><var>a</var>[<var>i_1</var>,<var>j_1</var>]</code> el elemento superior izquierdo y <code><var>a</var>[<var>i_2</var>,<var>j_2</var>]</code> el inferior derecho de la matriz. 
Aqu&iacute; <var>a</var> se declara como una arreglo (creado por <code>array</code>,
pero no por <code>make_array</code>), o un array no declarado, o una funci&oacute;n array, o una
expresi&oacute;n lambda de dos argumentos.
(An array function is created like other functions with <code>:=</code> or <code>define</code>,
but arguments are enclosed in square brackets instead of parentheses.)
</p>
<p>Si se omite <var>j_1</var>, entonces se le asigna el valor <var>i_1</var>. Si tanto <var>j_1</var> como <var>i_1</var> se omiten, a las dos variables se le asigna el valor 1.
</p>
<p>Si un elemento <code>i,j</code> del arreglo no est&aacute; definido, se le asignar&aacute; el elemento simb&oacute;lico <code><var>a</var>[i,j]</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) h [i, j] := 1 / (i + j - 1);
                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>gramschmidt</b><i> (<var>x</var>)</i>
<a name="IDX777"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>gschmit</b><i> (<var>x</var>)</i>
<a name="IDX778"></a>
</dt>
<dd><p>Ejecuta el algoritmo de ortogonalizaci&oacute;n de Gram-Schmidt sobre <var>x</var>, que puede ser una matriz o una lista de listas. La funci&oacute;n <code>gramschmidt</code> no altera el valor de <var>x</var>.
</p>
<p>Si <var>x</var> es una matriz, el algoritmo se aplica a las filas de <var>x</var>. Si  <var>x</var> es una lista de listas, el algoritmo se aplica a las sublistas, las cuales deben tener el mismo n&uacute;mero de miembros. En cualquier caso, el valor devuelto es una lista de listas, cuyas sublistas son ortogonales. </p>
<p>La funci&oacute;n <code>factor</code> es invocada  en cada paso del algoritmo para simplificar resultados intermedios. Como consecuencia, el valor retornado puede contener enteros factorizados.
</p>
<p>El nombre <code>gschmit</code> es sin&oacute;nimo de <code>gramschmidt</code>.
</p>
<p>Es necesario cargar la funci&oacute;n haciendo <code>load (&quot;eigen&quot;)</code>.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load (&quot;eigen&quot;)$
Warning - you are redefining the Macsyma function eigenvalues
Warning - you are redefining the Macsyma function eigenvectors
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) i: innerproduct$
(%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
(%o5)                       [0, 0, 0]
</pre></td></tr></table>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>ident</b><i> (<var>n</var>)</i>
<a name="IDX779"></a>
</dt>
<dd><p>Devuelve la matriz identidad de orden <var>n</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>innerproduct</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX780"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>inprod</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX781"></a>
</dt>
<dd><p>Devuelve el producto interior o escalar de <var>x</var> por <var>y</var>, que deben ser listas de igual longitud, o ambas matrices columa o fila de igual longitud. El valor devuelto es <code>conjugate (x) . y</code>, donde <code>.</code> es el operador de multiplicaci&oacute;n no conmutativa.
</p>
<p>Es necesario cargar la funci&oacute;n haciendo <code>load (&quot;eigen&quot;)</code>.
</p>
<p>El nombre <code>inprod</code> es sin&oacute;nimo de <code>innerproduct</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>invert</b><i> (<var>M</var>)</i>
<a name="IDX782"></a>
</dt>
<dd><p>Devuelve la inversa de la matriz <var>M</var>, calculada por el m&eacute;todo del adjunto.
</p>

<p>La implementaci&oacute;n actual no es eficiente para matrices de orden grande.
</p>
<p>Cuando <code>detout</code> vale <code>true</code>, el determinante queda fuera de la inversa a modo de factor escalar.
</p>
<p>Los elementos de la matriz inversa no se expanden. Si <var>M</var> tiene elementos polin&oacute;micos, se puede mejorar el aspecto del resultado haciendo <code>expand (invert (m)), detout</code>. </p>
<p>V&eacute;ase la descripci&oacute;n de <code>^^</code> (exponente no conmutativo) para informaci&oacute;n sobre otro m&eacute;todo para invertir matrices.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>lmxchar</b>
<a name="IDX783"></a>
</dt>
<dd><p>Valor por defecto: <code>[</code>
</p>
<p>La variable <code>lmxchar</code> guarda el car&aacute;cter a mostrar como delimitador izquierdo de la matriz.
V&eacute;ase tambi&eacute;n <code>rmxchar</code>.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) lmxchar: &quot;|&quot;$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>matrix</b><i> (<var>fila_1</var>, ..., <var>fila_n</var>)</i>
<a name="IDX784"></a>
</dt>
<dd><p>Devuelve una matriz rectangular con las filas  <var>fila_1</var>, ..., <var>fila_n</var>. Cada fila es una lista de expresiones. Todas las filas deben tener el mismo n&uacute;mero de miembros.
</p>
<p>Las operaciones <code>+</code> (suma), <code>-</code> (resta), <code>*</code> (multiplicaci&oacute;n) y <code>/</code> (divisi&oacute;n), se llevan a cabo elemento a elemento cuando los operandos son dos matrices, un escalar y una matriz o una matriz con un escalar. La operaci&oacute;n <code>^</code> (exponenciaci&oacute;n, equivalente a <code>**</code>) se lleva cabo tambi&eacute;n elemento a elemento si los operandos son un escalr y una matriz o uma matriz y un escalar, pero no si los operandos son dos matrices.
</p>
<p>El producto matricial se representa con el operador de multiplicaci&oacute;n no conmutativa <code>.</code>. El correspondiente operador de exponenciaci&oacute;n no conmutativa es <code>^^</code>. Dada la matriz <code><var>A</var></code>, <code><var>A</var>.<var>A</var> = <var>A</var>^^2</code> y <code><var>A</var>^^-1</code> es la inversa de <var>A</var>, si existe.
</p>
<p>Algunas variables controlan la simplificaci&oacute;n de expresiones que incluyan estas operaciones: <code>doallmxops</code>, <code>domxexpt</code>, <code>domxmxops</code>, <code>doscmxops</code> y <code>doscmxplus</code>.
</p>
<p>Hay otras opciones adicionales relacionadas con matrices:
<code>lmxchar</code>, <code>rmxchar</code>, <code>ratmx</code>, <code>listarith</code>, <code>detout</code>,
<code>scalarmatrix</code> y <code>sparse</code>.
</p>
<p>Hay tambi&eacute;n algunas funciones que admiten matrices como argumentos o que devuelven resultados matriciales: <code>eigenvalues</code>, <code>eigenvectors</code>,
<code>determinant</code>,
<code>charpoly</code>, <code>genmatrix</code>, <code>addcol</code>, <code>addrow</code>, 
<code>copymatrix</code>, <code>transpose</code>, <code>echelon</code> y <code>rank</code>.
</p>
<p>Ejemplos:
</p>
<ul>
<li>
Construcci&oacute;n de matrices a partir de listas.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
</pre></td></tr></table><ul>
<li>
Suma elemento a elemento.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
</pre></td></tr></table><ul>
<li>
Resta elemento a elemento.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
</pre></td></tr></table><ul>
<li>
Multiplicaci&oacute;n elemento a elemento.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
</pre></td></tr></table><ul>
<li>
Divisi&oacute;n elemento a elemento.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
</pre></td></tr></table><ul>
<li>
Matriz elevada a un exponente escalar, operaci&oacute;n elemento a elemento.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
</pre></td></tr></table><ul>
<li>
Base escalar y exponente matricial, operaci&oacute;n elemento a elemento.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre></td></tr></table><ul>
<li>
Base y exponente matriciales. Esta operaci&oacute;n no se realiza elemento a elemento.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
</pre></td></tr></table><ul>
<li>
Multiplicaci&oacute;n matricial no conmutativa.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
</pre></td></tr></table><ul>
<li>
Exponenciaci&oacute;n matricial no conmutativa. Una base escalar <var>b</var> elevada a un exponente matricial <var>M</var> se lleva a cabo elemento a elemento y por lo tanto <code>b^^m</code> equivale a <code>b^m</code>.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre></td></tr></table><ul>
<li>
Una matriz elevada al exponente -1 con el operador de exponenciaci&oacute;n no conmutativa equivale a la matriz inversa, si existe.
</li></ul>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i14) x ^^ -1;
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>matrixmap</b><i> (<var>f</var>, <var>M</var>)</i>
<a name="IDX785"></a>
</dt>
<dd><p>Devuelve una matriz con el elemento <code>i,j</code> igual a <code><var>f</var>(<var>M</var>[i,j])</code>.
</p>
<p>V&eacute;anse tambi&eacute;n <code>map</code>, <code>fullmap</code>, <code>fullmapl</code> y <code>apply</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>matrixp</b><i> (<var>expr</var>)</i>
<a name="IDX786"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> es una matriz, en caso contrario <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>matrix_element_add</b>
<a name="IDX787"></a>
</dt>
<dd><p>Valor por defecto: <code>+</code>
</p>
<p>La variable <code>matrix_element_add</code> guarda el s&iacute;mbolo del operador a ejecutar en lugar de la suma en el producto matricial; a <code>matrix_element_add</code> se le puede asignar cualquier operador n-ario (esto es, una funci&oacute;n que admite cualquier n&uacute;mero de argumentos). El valor asignado puede ser el nombre de un operador encerrado entre ap&oacute;strofos, el nombre de una funci&oacute;n o una expresi&oacute;n lambda.
</p>
<p>V&eacute;anse tambi&eacute;n <code>matrix_element_mult</code> y <code>matrix_element_transpose</code>.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) matrix_element_add: &quot;*&quot;$
(%i2) matrix_element_mult: &quot;^&quot;$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
</pre></td></tr></table>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>matrix_element_mult</b>
<a name="IDX788"></a>
</dt>
<dd><p>Valor por defecto: <code>*</code>
</p>
<p>La variable <code>matrix_element_mult</code> guarda el s&iacute;mbolo del operador a ejecutar en lugar de la multiplicaci&oacute;n en el producto matricial; a <code>matrix_element_mult</code> se le puede asignar cualquier operador binario. El valor asignado puede ser el nombre de un operador encerrado entre ap&oacute;strofos, el nombre de una funci&oacute;n o una expresi&oacute;n lambda.
</p>
<p>El operador <code>.</code> puede ser una opci&oacute;n &uacute;til en determinados contextos.
</p>
<p>V&eacute;anse tambi&eacute;n <code>matrix_element_add</code> y <code>matrix_element_transpose</code>.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) matrix_element_add: lambda ([[x]], sqrt (apply (&quot;+&quot;, x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>matrix_element_transpose</b>
<a name="IDX789"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>matrix_element_transpose</code> es una operaci&oacute;n que se aplica a cada elemento de una matriz a la que se le calcula la transpuesta. A <code>matrix_element_mult</code> se le puede asignar cualquier operador unitario. El valor asignado puede ser el nombre de un operador encerrador entre ap&oacute;strofos, el nombre de una funci&oacute;n o una expresi&oacute;n lambda.
</p>
<p>Cuando <code>matrix_element_transpose</code> es igual a <code>transpose</code>, la funci&oacute;n <code>transpose</code> se aplica a cada elemento. Cuando  <code>matrix_element_transpose</code> es igual  a <code>nonscalars</code>, la funci&oacute;n <code>transpose</code> se aplica a todos los elementos no escalares. Si alguno de los elementos es un &aacute;tomo, la opci&oacute;n <code>nonscalars</code> se aplica 
<code>transpose</code> s&oacute;lo si el &aacute;tomo se declara no escalar, mientras que la opci&oacute;n <code>transpose</code> siempre aplica  <code>transpose</code>.
</p>
<p>La opci&oacute;n por defecto, <code>false</code>, significa que no se aplica ninguna operaci&oacute;n.
</p>
<p>V&eacute;anse tambi&eacute;n <code>matrix_element_add</code> y <code>matrix_element_mult</code>.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
</pre></td></tr></table>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>mattrace</b><i> (<var>M</var>)</i>
<a name="IDX790"></a>
</dt>
<dd><p>Devuelve la traza (esto es, la suma de los elementos de la diagonal principal) de la matriz cuadrada <var>M</var>.  
</p>
<p>Para disponer de esta funci&oacute;n es necesario cargar el paquete haciendo <code>load (&quot;nchrpl&quot;)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>minor</b><i> (<var>M</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX791"></a>
</dt>
<dd><p>Devuelve el menor <code>(<var>i</var>, <var>j</var>)</code> de la matriz <var>M</var>.  Esto es, la propia matriz <var>M</var>, una vez extra&iacute;das la fila <var>i</var> y la columna <var>j</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ncexpt</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX792"></a>
</dt>
<dd><p>Si una expresi&oacute;n exponencial no conmutativa es demasiado grande para mostrarse en la forma <code><var>a</var>^^<var>b</var></code> entonces aparece como <code>ncexpt (<var>a</var>,<var>b</var>)</code>.
</p>
<p>El nombre <code>ncexpt</code> no corresponde al de una funci&oacute;n u operador, sino que tan solo aparece en la salida y no se reconoce como una entrada v&aacute;lida.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ncharpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX793"></a>
</dt>
<dd><p>Devuelve el polinomio caracter&iacute;stico de la matriz <var>M</var> respecto de la variable <var>x</var>. Es una alternativa a la funci&oacute;n <code>charpoly</code> de Maxima.
</p>
<p>La funci&oacute;n <code>ncharpoly</code> opera calculando trazas de las potencias de la matriz dada, que son iguales a las sumas de las potencias de las ra&iacute;ces del polinomio caracter&iacute;stico. A partir de estas cantidades se pueden calcular las funciones sim&eacute;tricas de las ra&iacute;ces, que no son otra cosa sino los coeficientes del polinomio caracter&iacute;stico. La funci&oacute;n   <code>charpoly</code> opera calculando el determinante de  by <code><var>x</var> * ident [n] - a</code>. La funci&oacute;n <code>ncharpoly</code> es m'as eficiente en el caso de matrices grandes y densas.
</p>
<p>Para disponer de esta funci&oacute;n es necesario cargar el paquete haciendo <code>load (&quot;nchrpl&quot;)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>newdet</b><i> (<var>M</var>, <var>n</var>)</i>
<a name="IDX794"></a>
</dt>
<dd><p>Calcula el determinante de la matriz o arreglo <var>M</var> por el algoritmo del &aacute;rbol menor de Johnson-Gentleman.
El argumento <var>n</var> es el orden; es opcional si <var>M</var> es una matriz.
</p>
</dd></dl>

<dl>
<dt><u>Declaraci&oacute;n:</u> <b>nonscalar</b>
<a name="IDX795"></a>
</dt>
<dd><p>Hace que los &aacute;tomos se comporten como hace una lista o matriz con respecto del operador <code>.</code> del la multiplicaci&oacute;n no conmutativa.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>nonscalarp</b><i> (<var>expr</var>)</i>
<a name="IDX796"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> no es escalar, es decir, si contiene &aacute;tomos declarados como no escalares, listas o matrices.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>permanent</b><i> (<var>M</var>, <var>n</var>)</i>
<a name="IDX797"></a>
</dt>
<dd><p>Calcula la permanente de la matriz <var>M</var>. La permanente es como un determinante pero sin cambios de signo.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>rank</b><i> (<var>M</var>)</i>
<a name="IDX798"></a>
</dt>
<dd><p>Calcula el rango de la matriz <var>M</var>.  Esto es, el orden del mayor subdeterminante no singular de <var>M</var>.
</p>
<p>La funci&oacute;n <var>rango</var> puede retornar una respuesta err&oacute;nea si no detecta que un elemento de la matriz equivalente a cero lo es.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratmx</b>
<a name="IDX799"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>ratmx</code> vale <code>false</code>, el determinante y la suma, resta y producto matriciales se calculan cuando las matrices se expresan en t&eacute;rminos de sus elementos, pero no se calcula la inversi&oacute;n matricial en su representaci&oacute;n general.
</p>
<p>Si <code>ratmx</code> vale <code>true</code>, las cuatro operaciones citadas m&aacute;s arriba se calculan en el formato CRE y el resultado de la matriz inversa tambi&eacute;n se da en formato CRE. Esto puede hacer que se expandan los elementos de la matriz, dependiendo del valor de <code>ratfac</code>, lo que quiz&aacute;s no sea siempre deseable.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>row</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX800"></a>
</dt>
<dd><p>Devuelve la <var>i</var>-&eacute;sima fila de la matriz <var>M</var>. El valor que devuelve tiene formato de matriz.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>scalarmatrixp</b>
<a name="IDX801"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>scalarmatrixp</code> vale <code>true</code>, entonces siempre que una matriz 1 x 1 se produce como resultado del c&aacute;lculo del producto no conmutativo de matrices se cambia al formato escalar.
</p>
<p>Si <code>scalarmatrixp</code> vale <code>all</code>, entonces todas las matrices 1 x 1 se simplifican a escalares.
</p>
<p>Si <code>scalarmatrixp</code> vale <code>false</code>, las matrices 1 x 1 no se convierten en escalares.
</p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>setelmx</b><i> (<var>x</var>, <var>i</var>, <var>j</var>, <var>M</var>)</i>
<a name="IDX802"></a>
</dt>
<dd><p>Asigna el valor <var>x</var> al (<var>i</var>, <var>j</var>)-&eacute;simo elemento de la matriz <var>M</var> y devuelve la matriz actualizada.
</p>
<p>La llamada <code><var>M</var> [<var>i</var>, <var>j</var>]: <var>x</var></code> hace lo mismo, pero devuelve  <var>x</var> en lugar de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>similaritytransform</b><i> (<var>M</var>)</i>
<a name="IDX803"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>simtran</b><i> (<var>M</var>)</i>
<a name="IDX804"></a>
</dt>
<dd><p>La funci&oacute;n <code>similaritytransform</code> calcula la transformada de similitud de la matriz <code>M</code>. Devuelve una lista que es la salida de la instrucci&oacute;n <code>uniteigenvectors</code>. Adem&aacute;s, si la variable <code>nondiagonalizable</code> vale <code>false</code> entonces se calculan dos matrices globales <code>leftmatrix</code> y <code>rightmatrix</code>. Estas matrices tienen la propiedad de que <code>leftmatrix . <var>M</var> . rightmatrix</code> es una matriz diagonal con los valores propios de <var>M</var> en su diagonal.  Si <code>nondiagonalizable</code> vale <code>true</code> entonces no se calculan estas matrices.
</p>
<p>Si la variable <code>hermitianmatrix</code> vale <code>true</code> entonces <code>leftmatrix</code> es el conjugado complejo de la transpuesta de <code>rightmatrix</code>.  En otro caso <code>leftmatrix</code> es la inversa de <code>rightmatrix</code>.
</p>
<p>Las columnas de la matriz <code>rightmatrix</code> son los vectores propios de <var>M</var>.  Las otras variables (v&eacute;anse <code>eigenvalues</code> y <code>eigenvectors</code>) tienen el mismo efecto, puesto que <code>similaritytransform</code> llama a las otras funciones del paquete para poder formar <code>rightmatrix</code>.
</p>
<p>Estas funciones se cargan con <code>load (&quot;eigen&quot;)</code>.
</p>
<p>El nombre <code>simtran</code> es sin&oacute;nimo de <code>similaritytransform</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>sparse</b>
<a name="IDX805"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>sparse</code> vale <code>true</code> y si <code>ratmx</code> vale <code>true</code>, entonces <code>determinant</code>
utilizar&aacute; rutinas especiales para calcular determinantes dispersos.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>submatrix</b><i> (<var>i_1</var>, ..., <var>i_m</var>, <var>M</var>, <var>j_1</var>, ..., <var>j_n</var>)</i>
<a name="IDX806"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>submatrix</b><i> (<var>i_1</var>, ..., <var>i_m</var>, <var>M</var>)</i>
<a name="IDX807"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>submatrix</b><i> (<var>M</var>, <var>j_1</var>, ..., <var>j_n</var>)</i>
<a name="IDX808"></a>
</dt>
<dd><p>Devuelve una nueva matriz formada a partir de la matriz <var>M</var> pero cuyas filas <var>i_1</var>, ..., <var>i_m</var> y columnas  <var>j_1</var>, ..., <var>j_n</var> han sido eliminadas.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>transpose</b><i> (<var>M</var>)</i>
<a name="IDX809"></a>
</dt>
<dd><p>Calcula la transpuesta de <var>M</var>.
</p>
<p>Si <var>M</var> es una matriz, el valor devuelto es otra matriz <var>N</var> tal que <code>N[i,j] = M[j,i]</code>.
</p>
<p>Si <var>M</var> es una lista, el valor devuelto es una matriz <var>N</var> de <code>length (m)</code> filas y 1 columna, tal que <code>N[i,1] = M[i]</code>.
</p>
<p>En caso de no ser <var>M</var> ni matriz ni lista, se devuelve la
expresi&oacute;n nominal <code>'transpose (<var>M</var>)</code>.
</p></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>triangularize</b><i> (<var>M</var>)</i>
<a name="IDX810"></a>
</dt>
<dd><p>Devuelve la forma triangular superior de la matriz <code>M</code>, obtenida por eliminaci&oacute;n gaussiana.
El resultado es el mismo que el devuelto por <code>echelon</code>, con la salvedad de que el primer elemento no nulo de cada fila no se normaliza a 1.
</p>
<p>Las funciones <code>lu_factor</code> y <code>cholesky</code> tambi&eacute;n triangularizan matrices.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>uniteigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX811"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>ueivects</b><i> (<var>M</var>)</i>
<a name="IDX812"></a>
</dt>
<dd><p>Calcula los vectores propios unitarios de la matriz <var>M</var>. El valor que devuelve es una lista de listas, la primera de las cuales es la salida de la funci&oacute;n <code>eigenvalues</code> y el resto de sublistas son los vectores propios unitarios de la matriz correspondiente a esos valores propios, respectivamente.
</p>
<p>Las variables citadas en la descripci&oacute;n de la funci&oacute;n <code>eigenvectors</code> tienen los mismos efectos en <code>uniteigenvectors</code>.
</p>
<p>Si <code>knowneigvects</code> vale <code>true</code>, el paquete <code>eigen</code> da por supuesto que el usuario conoce los vectores propios de la matriz y que est&aacute;n guardados en la variable global <code>listeigvects</code>, en tal caso el contenido de  <code>listeigvects</code> debe ser una lista de estructura similar a la que devuelve la funci&oacute;n <code>eigenvectors</code>.
</p>
<p>Si <code>knowneigvects</code> vale <code>true</code> y la lista de vectores propios est&aacute; en la variable <code>listeigvects</code>, el valor de la variable <code>nondiagonalizable</code> puede que no sea el correcto. Si tal es el caso, debe asignarsele el valor correcto. </p>
<p>Para utilizar esta fucni&oacute;n es necesario cargarla haciendo <code>load (&quot;eigen&quot;)</code>.
</p>
<p>El nombre <code>ueivects</code> es sin&oacute;nimo de <code>uniteigenvectors</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>unitvector</b><i> (<var>x</var>)</i>
<a name="IDX813"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>uvect</b><i> (<var>x</var>)</i>
<a name="IDX814"></a>
</dt>
<dd><p>Devuelve <em><var>x</var>/norm(<var>x</var>)</em>, esto es, el vector unitario de igual direcci&oacute;n y sentido que <var>x</var>.
</p>
<p><code>load (&quot;eigen&quot;)</code> loads this function.
</p>
<p>Para utilizar esta fucni&oacute;n es necesario cargarla haciendo <code>load (&quot;eigen&quot;)</code>.
</p>
<p>El nombre <code>uvect</code> es sin&oacute;nimo de <code>unitvector</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>vectorsimp</b><i> (<var>expr</var>)</i>
<a name="IDX815"></a>
</dt>
<dd><p>Realiza simplificaciones y expansiones de acuerdo con los valores de las siguientes variables globales:
</p>
<p><code>expandall</code>, <code>expanddot</code>, <code>expanddotplus</code>, <code>expandcross</code>, <code>expandcrossplus</code>,
<code>expandcrosscross</code>, <code>expandgrad</code>, <code>expandgradplus</code>, <code>expandgradprod</code>,
<code>expanddiv</code>, <code>expanddivplus</code>, <code>expanddivprod</code>, <code>expandcurl</code>, <code>expandcurlplus</code>,
<code>expandcurlcurl</code>, <code>expandlaplacian</code>, <code>expandlaplacianplus</code> y <code>expandlaplacianprod</code>.
</p>
<p>Todas estas variables tienen por defecto el valor <code>false</code>. El sufijo <code>plus</code> se refiere al uso de la suma o la distributividad.  El sufijo <code>prod</code> se refiere a la expansi&oacute;n de operadores que realizan cualquier tipo de producto.
</p>
<dl compact="compact">
<dt> <code>expandcrosscross</code></dt>
<dd><p>Simplifica <em>p ~ (q ~ r)</em> en <em>(p . r)*q - (p . q)*r</em>.
</p></dd>
<dt> <code>expandcurlcurl</code></dt>
<dd><p>Simplifica <em>curl curl p</em> en <em>grad div p + div grad p</em>.
</p></dd>
<dt> <code>expandlaplaciantodivgrad</code></dt>
<dd><p>Simplifica <em>laplacian p</em> en <em>div grad p</em>.
</p></dd>
<dt> <code>expandcross</code></dt>
<dd><p>Activa <code>expandcrossplus</code> y <code>expandcrosscross</code>.
</p></dd>
<dt> <code>expandplus</code></dt>
<dd><p>Activa <code>expanddotplus</code>, <code>expandcrossplus</code>, <code>expandgradplus</code>,
<code>expanddivplus</code>, <code>expandcurlplus</code> y <code>expandlaplacianplus</code>.
</p></dd>
<dt> <code>expandprod</code></dt>
<dd><p>Activa <code>expandgradprod</code>, <code>expanddivprod</code> y <code>expandlaplacianprod</code>.
</p></dd>
</dl>

<p>Estas variables est&aacute;n declaradas como <code>evflag</code>.
</p>

</dd></dl>




<dl>
<dt><u>Funci&oacute;n:</u> <b>zeromatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX816"></a>
</dt>
<dd><p>Devuelve una matriz rectangular <var>m</var> por <var>n</var> con todos sus elementos iguales a cero.
</p>
</dd></dl>

<dl>
<dt><u>S&iacute;mbolo especial:</u> <b>[</b>
<a name="IDX817"></a>
</dt>
<dt><u>S&iacute;mbolo especial:</u> <b>[</b>
<a name="IDX818"></a>
</dt>
<dd><p>Los s&iacute;mbolos <code>[</code> y <code>]</code> marcan el comienzo y final, respectivamente, de una lista.
</p>
<p>Los s&iacute;mbolos <code>[</code> y <code>]</code> tambi&eacute;n se utilizan para indicar los sub&iacute;ndices de los elementos de una lista, arreglo o funci&oacute;n arreglo.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) x: [a, b, c];
(%o1)                       [a, b, c]
(%i2) x[3];
(%o2)                           c
(%i3) array (y, fixnum, 3);
(%o3)                           y
(%i4) y[2]: %pi;
(%o4)                          %pi
(%i5) y[2];
(%o5)                          %pi
(%i6) z['foo]: 'bar;
(%o6)                          bar
(%i7) z['foo];
(%o7)                          bar
(%i8) g[k] := 1/(k^2+1);
                                  1
(%o8)                     g  := ------
                           k     2
                                k  + 1
(%i9) g[10];
                                1
(%o9)                          ---
                               101
</pre></td></tr></table>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC81" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC87" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>mayo, 2 2007</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
