<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on mayo, 2 2007 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 40. Programaci&oacute;n</title>

<meta name="description" content="Manual de Maxima: 40. Programaci&oacute;n">
<meta name="keywords" content="Manual de Maxima: 40. Programaci&oacute;n">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,180); /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    font-family: "Lucida Console", monospace
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}
-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Programaci_00f3n"></a>
<a name="SEC157"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_39.html#SEC156" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC158" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_39.html#SEC150" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 40. Programaci&oacute;n </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC158">40.1 Introducci&oacute;n a la Programaci&oacute;n</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC159">40.2 Definiciones para la Programaci&oacute;n</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-la-Programaci_00f3n"></a>
<a name="SEC158"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC157" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC159" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC157" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC157" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 40.1 Introducci&oacute;n a la Programaci&oacute;n </h2>

<p>Maxima dispone de los bucles <code>do</code> para hacer iteraciones, as&iacute; como estructuras m&aacute;s primitivas del estilo de <code>go</code>.
</p>

<hr size="6">
<a name="Definiciones-para-la-Programaci_00f3n"></a>
<a name="SEC159"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC158" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC160" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC157" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC157" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 40.2 Definiciones para la Programaci&oacute;n </h2>

<dl>
<dt><u>Funci&oacute;n:</u> <b>backtrace</b><i> ()</i>
<a name="IDX1334"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>backtrace</b><i> (<var>n</var>)</i>
<a name="IDX1335"></a>
</dt>
<dd><p>Devuelve la pila de llamadas, esto es, la lista de funciones que han llamado a la funci&oacute;n actualmente activa.
</p>
<p>La llamada a <code>backtrace()</code> devuelve la pila completa de llamadas.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
</pre></td></tr></table>
<p>La llamada <code>backtrace (<var>n</var>)</code> devuelve las <var>n</var> funciones m&aacute;s recientes, incluyendo a la funci&oacute;n actualmente activa.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>do</b>
<a name="IDX1336"></a>
</dt>
<dd><p>La sentencia <code>do</code> se utiliza para realizar iteraciones.  Debido a su generalidad la sentencia <code>do</code> se describir&aacute; en dos partes. En primer lugar se mostrar&aacute; su forma m&aacute;s usual, an&aacute;loga a la de otros lenguajes de programaci&oacute;n (Fortran, Algol, PL/I, etc.); despu&eacute;s se mencionar&aacute;n otras formas de uso.
</p>
<p>Hay tres variantes de esta sentencia que se diferencian entre s&iacute; &uacute;nicamente por las condiciones de fin de bucle. Son las siguientes:
</p>
<ul>
<li>
<code>for <var>variable</var>: <var>valor_inicial</var> step <var>incremento</var>
      thru <var>l&iacute;mite</var> do <var>cuerpo</var></code>
</li><li>
<code>for <var>variable</var>: <var>valor_inicial</var> step <var>incremento</var>
      while <var>condici&oacute;n</var> do <var>cuerpo</var></code>
</li><li>
<code>for <var>variable</var>: <var>valor_inicial</var> step <var>incremento</var>
      unless <var>condici&oacute;n</var> do <var>cuerpo</var></code>
</li></ul>

<p>El <var>valor_inicial</var>, el <var>incremento</var>, el <var>l&iacute;mite</var> y el <var>cuerpo</var> pueden ser cualquier tipo de expresi&oacute;n v&aacute;lida de Maxima. Si el incremento es igual a la unidad (1) entonces &quot;<code>step 1</code>&quot; puede omitirse.
</p>
<p>La ejecuci&oacute;n de la sentencia <code>do</code> se realiza asignando el valor_inicial a la variable (llamada de aqu&iacute; en adelante variable-control). A continuaci&oacute;n: (1) si la variable-control ha excedido el l&iacute;mite de la especificaci&oacute;n dada por un <code>thru</code>, o si la condici&oacute;n impuesta por <code>unless</code> es verdadera (<code>true</code>), o si la condici&oacute;n dada por <code>while</code> es falsa (<code>false</code>) entonces la iteraci&oacute;n <code>do</code> termina. (2) El cuerpo se eval&uacute;a.  (3) El incremento es sumado a la variable-control. El proceso de (1) a (3) se repite hasta que la condici&oacute;n de fin de iteraci&oacute;n se satisfaga. Tambi&eacute;n es posible especificar varias condiciones de terminaci&oacute;n del bucle, en cuyo caso <code>do</code> terminar&aacute; cuando se satisfaga alguna de ellas.
</p>
<p>En general la condici&oacute;n <code>thru</code> se satisfar&aacute; cuando la variable-control sea mayor que el l&iacute;mite si el incremento es no negativo, o cuando la variable-control sea menor que el l&iacute;mite cuando el incremento es negativo. El incremento y el l&iacute;mite pueden ser expresiones no num&eacute;ricas, tanto en cuanto esta desigualdad pueda quedar determinada. Sin embargo, a menos que el incremento sea un n&uacute;mero negativo en el momento de comenzar el c&oacute;mputo de <code>do</code>, Maxima supondr&aacute; que se evaluar&aacute; a una cantidad positiva. En caso de no ser efectivamente positivo, la sentencia <code>do</code> puede dar un resultado inesperado.
</p>
<p>N&oacute;tese que el l&iacute;mite, el incremento y la condici&oacute;n de terminaci&oacute;n se eval&uacute;an en cada iteraci&oacute;n del bucle. As&iacute;, si alguna de expresiones necesitan de muchos c&aacute;lculos y devuelven un resultado que no va a cambiar durante toda la ejecuci&oacute;n del cuerpo, ser&aacute; m&aacute;s eficiente dar este valor a una variable antes de comenzar la sentencia <code>do</code> y utilizarla luego durante su ejecuci&oacute;n.
</p>
<p>El valor que habitualmente devuelva la sentencia <code>do</code> ser&aacute; el &aacute;tomo <code>done</code>. Sin embargo, la funci&oacute;n <code>return</code> puede usarse dentro del cuerpo para salir de <code>do</code> de forma prematura retornando un valor determinado.
N&oacute;tese no obstante que un <code>return</code> dentro de un <code>do</code> que est&aacute; dentro de un bloque (<code>block</code>) provocar&aacute; una salida de <code>do</code> pero no de <code>block</code>. Rep&aacute;rese tambi&eacute;n en que la funci&oacute;n <code>go</code> no puede usarse para salir de <code>do</code> e ir a alg&uacute;n lugar de <code>block</code>.
</p>
<p>La variable-control es siempre local respecto de <code>do</code>, por lo que se puede utilizar cualquier nombre de variable sin afectar el valor de cualquier otra variable externa a <code>do</code> y que tenga el mismo nombre. La variable-control no tendr&aacute; asignado ning&uacute;n valor una vez se haya concluido el <code>do</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
</pre></td></tr></table>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) s: 0$
(%i2) for i: 1 while i &lt;= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
</pre></td></tr></table>

<p>N&oacute;tese que la condici&oacute;n <code>while i &lt;= 10</code> es equivalente a <code>unless i &gt; 10</code> y a <code>thru 10</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p &gt; 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
</pre></td></tr></table>
<p>lo que da ocho t&eacute;rminos del desarrollo de Taylor de la funci&oacute;n <code>e^sin(x)</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) &lt; 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
</pre></td></tr></table>
<p>Este ejemplo calcula la ra&iacute;z cuadrada negativa de 10 haciendo 10 iteraciones del m&eacute;todo de Newton-Raphson. De no haberse alcanzado el criterio de convergencia el valor devuelto hubiese sido <code>done</code>.
</p>
<p>En lugar de a&ntilde;adir siempre una cantidad a la variable-control a veces se puede querer que cambie en cada iteraci&oacute;n siguiendo alg&uacute;n otro criterio. En tal caso se puede hacer uso de <code>next <var>expresi&oacute;n</var></code> en lugar de <code>step <var>incremento</var></code>. Esto har&aacute; que a la variable-control se le asigne el resultado de evaluar la expresi&oacute;n en cada iteraci&oacute;n del bucle.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
</pre></td></tr></table>
<p>En ocasiones puede interesar realizar una iteraci&oacute;n en la que la variable-control no se utilice nunca. Se podr&aacute; entonces dar &uacute;nicamente las condiciones de terminaci&oacute;n del bucle omitiendo la inicializaci&oacute;n y actualizando la informaci&oacute;n, tal como se hace en el siguiente ejemplo para calcular la ra&iacute;z cuadrada de 5 utilizando un valor inicial alejado de la soluci&oacute;n.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
</pre></td></tr></table>
<p>Si as&iacute; se quiere, incluso es posible omitir las condiciones de terminaci&oacute;n completamente y escribir &uacute;nicamente <code>do <var>body</var></code>, lo que provocar&aacute; entrar en un bucle infinito. En tal caso, deber&iacute;a usarse la funci&oacute;n <code>return</code> a fin de terminar con la ejecuci&oacute;n de <code>do</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) &lt; 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
</pre></td></tr></table>
<p>(En este ejemplo, cuando se ejecuta <code>return</code> obliga a que sea <code>x</code> el valor devuelto por <code>do</code>. Al salirse del bloque, <code>x</code> es tambi&eacute;n el valor que devuelve <code>block</code> por ser <code>do</code> la &uacute;ltima sentencia del bloque.)
</p>
<p>Hay todav&iacute;a otra forma de <code>do</code> en Maxima. Su sintaxis es:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">for <var>variable</var> in <var>lista</var> <var>test_de_parada</var> do <var>cuerpo</var>
</pre></td></tr></table>
<p>Los elementos de <var>list</var> son cualesquiera expresiones que se ir&aacute;n asignando sucesivamente a la variable en cada repetici&oacute;n del cuerpo. El test de parada <var>end_tests</var> (que es opcional) puede usarse para terminar la ejecuci&oacute;n de <code>do</code>; de otro modo las iteraciones se parar&aacute;n cuando la lista se haya agotado o cuando se ejecute un <code>return</code> dentro del cuerpo.  (De hecho, la lista puede ser cualquier expresi&oacute;n no at&oacute;mica, de la cual se ir&aacute;n extrayendo de forma sucesiva sus diferentes partes.)
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
</pre></td></tr></table>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>errcatch</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1337"></a>
</dt>
<dd><p>Eval&uacute;a las expresiones <var>expr_1</var>, ..., <var>expr_n</var> una a una y devuelve <code>[<var>expr_n</var>]</code> (una lista) en caso de que no ocurra ning&uacute;n error. En caso de aparecer alg&uacute;n error durante el c&aacute;lculo de alguno de los argumentos, <code>errcatch</code> evita que el error se propague y devuelve la lista vac&iacute;a <code>[]</code> sin evaluar m&aacute;s argumentos.
</p>
<p>La funci&oacute;n <code>errcatch</code> es &uacute;til en ficheros <code>batch</code> donde se sospeche que pueda aparecer alg&uacute;n error, el cual provocar&iacute;a la terminaci&oacute;n de la ejecuci&oacute;n del <code>batch</code> de no ser previamente detectado.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>error</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1338"></a>
</dt>
<dt><u>Variable del sistema:</u> <b>error</b>
<a name="IDX1339"></a>
</dt>
<dd><p>Calcula y devuelve <var>expr_1</var>, ..., <var>expr_n</var>, enviando posteriormente una se&atilde;l de error a Maxima o al <code>errcatch</code> m&aacute;s cercano. 
</p>
<p>A la variable <code>error</code> se le asigna una lista con la descripci&oacute;n del error. El primer elemento de <code>error</code> es una cadena de formato, la cual une todas las cadenas de los argumentos <var>expr_1</var>, ..., <var>expr_n</var>, siendo los dem&aacute;s elementos de la lista los valores de los argumentos que no son cadenas.
</p>
<p>La llamada a <code>errormsg()</code> formatea e imprime <code>error</code>. Se reimprime as&iacute; el mensaje de error m&aacute;s reciente.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>errormsg</b><i> ()</i>
<a name="IDX1340"></a>
</dt>
<dd><p>Reimprime el mensaje de error m&aacute;s reciente. La variable <code>error</code> guarda el mensaje y <code>errormsg</code> lo formatea e imprime.
</p>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>for</b>
<a name="IDX1341"></a>
</dt>
<dd><p>Utilizado en las iteraciones. V&eacute;ase <code>do</code> para una descripci&oacute;n de las t&eacute;cnicas de iteraci&oacute;n en Maxima.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>go</b><i> (<var>etiqueta</var>)</i>
<a name="IDX1342"></a>
</dt>
<dd><p>Se utiliza dentro de un bloque (<code>block</code>) para transferir el control a la sentencia del bloque que est&eacute; etiquetada con el argumento de <code>go</code>. Una sentencia queda etiquetada cuando est&aacute; precedida por un argumento de tipo &aacute;tomo como cualquier otra sentencia de <code>block</code>.  Por ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">block ([x], x:1, tururu, x+1, ..., go(tururu), ...)
</pre></td></tr></table>
<p>El argumento de <code>go</code> debe ser el nombre de una etiqueta que aparezca en el mismo bloque (<code>block</code>). No se puede utilizar <code>go</code> para transferir el control a un bloque que no sea aquel que contenga la sentencia <code>go</code>.
</p>
</dd></dl>

<dl>
<dt><u>Operador especial:</u> <b>if</b>
<a name="IDX1343"></a>
</dt>
<dd><p>Evaluaci&oacute;n condicionada. Se reconocen varias formas de expresiones <code>if</code>.
</p>
<p>La expresi&oacute;n <code>if <var>cond_1</var> then <var>expr_1</var> else <var>expr_0</var></code>
devuelve <var>expr_1</var> si <var>cond_1</var> vale <code>true</code>,
en caso contrario la respuesta es <code>expr_0</code>.
</p>
<p>La expresi&oacute;n <code>if <var>cond_1</var> then <var>expr_1</var> elseif <var>cond_2</var>
then <var>expr_2</var> elseif ... else <var>expr_0</var></code>
devuelve <var>expr_k</var> si <var>cond_k</var> vale <code>true</code> y todas las
condiciones anteriores toman el valor <code>false</code>.
Si ninguna de las condiciones vale <code>true</code>, la respuesta es <code>expr_0</code>.
</p>
<p>La falta de un <code>else</code> final se interpreta como un <code>else false</code>;
esto es, la expresi&oacute;n <code>if <var>cond_1</var> then <var>expr_1</var></code>
equivale a <code>if <var>cond_1</var> then <var>expr_1</var> else false</code>,
y <code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var></code>
equivale a su vez a
<code>if <var>cond_1</var> then <var>expr_1</var> elseif ... elseif <var>cond_n</var> then <var>expr_n</var> else false</code>.
</p>
<p>Las alternativas <var>expr_0</var>, ..., <var>expr_n</var> pueden ser expresiones
v&aacute;lidas de Maxima, incluidas expresiones <code>if</code> anidadas.
Las alternativas ni se simplifican ni se eval&uacute;an, a menos que su
condici&oacute;n asociada valga <code>true</code>.
</p>
<p>Las condiciones <var>cond_1</var>, ..., <var>cond_n</var> deben ser expresiones 
capaces de dar como resultado <code>true</code> o <code>false</code> al ser
evaluadas. Si en un momento dado una condici&oacute;n no da como resultado 
un valor de verdad (<code>true</code> o <code>false</code>), el comportamiento de <code>if</code> se controla
con la variable global <code>prederror</code>. Si <code>prederror</code> vale <code>true</code>,
se considera un error que la condici&oacute;n evaluada no d&eacute; como resultado
un valor de verdad; en caso contrario, las condiciones que no
den como resultado un valor de verdad se aceptan, d&aacute;ndose el
resultado como una expresi&oacute;n condicional.
</p>
<p>Las condiciones pueden contener operadores l&oacute;gicos y relacionales, 
as&iacute; como otros elementos, tal como se indica a continuaci&oacute;n:
</p>

<table><tr><td>&nbsp;</td><td><pre class="example">Operaci&oacute;n               S&iacute;mbolo     Tipo
 
menor que               &lt;           operador relacional infijo
menor o igual que       &lt;=          operador relacional infijo
igualdad (sint&aacute;ctica)   =           operador relacional infijo
negaci&oacute;n de =           #           operador relacional infijo
igualdad (por valor)    equal       operador relacional infijo
negaci&oacute;n de equal       notequal    operador relacional infijo
mayor o igual que       &gt;=          operador relacional infijo
mayor que               &gt;           operador relacional infijo
y                       and         operador l&oacute;gico infijo
o                       or          operador l&oacute;gico infijo
no                      not         operador l&oacute;gico prefijo
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>map</b><i> (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1344"></a>
</dt>
<dd><p>Devuelve una expresi&oacute;n cuyo operador principal es el mismo que aparece en las expresiones <var>expr_1</var>, ..., <var>expr_n</var> pero cuyas subpartes son los resultados de aplicar <var>f</var> a cada una de las subpartes de las expresiones;  <var>f</var> puede ser tanto el nombre de una funci&oacute;n de <em>n</em> argumentos o una forma <code>lambda</code> de <em>n</em> argumentos.
</p>
<p>Uno de los usos que tiene <code>map</code> es la de aplicar (o mapear) una funci&oacute;n (por ejemplo, <code>partfrac</code>) sobre cada t&eacute;rmino de una expresi&oacute;n extensa en la que normalmente no se podr&iacute;a utilizar la funci&oacute;n debido a insuficiencias en el espacio de almacenamiento durante el curso de un c&aacute;lculo.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map(&quot;=&quot;,[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]
</pre></td></tr></table></dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>mapatom</b><i> (<var>expr</var>)</i>
<a name="IDX1345"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y s&oacute;lo <var>expr</var> es tratado por las rutinas de mapeo como un &aacute;tomo.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>maperror</b>
<a name="IDX1346"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>maperror</code> toma el valor <code>false</code>, hace que todas las funciones de mapeo, como por ejemplo
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">map (f, expr_1, expr_2, ...))
</pre></td></tr></table>
<p>(1) paren cuando hayan terminado de procesar la expi m&aacute;s corta, a menos que todas ellas sean del mismo tama&ntilde;o y (2) apliquen  <code>f</code> a <code>[expr_1, expr_2, ...]</code> si es el caso que las <code>expr_i</code> no son todas del mismo tipo de objeto.
</p>
<p>Cuando <code>maperror</code> toma el valor <code>true</code> entonces se emite un mensaje de error cuando se presenta cualquiera de los dos casos anteriores.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>maplist</b><i> (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1347"></a>
</dt>
<dd><p>Devuelve una lista con las aplicaciones de <var>f</var> a las partes de las expresiones <var>expr_1</var>, ..., <var>expr_n</var>; <var>f</var> es el nombre de una funci&oacute;n ou una expresi&oacute;n lambda.
</p>
<p>La funci&oacute;n <code>maplist</code> difiere de <code>map (<var>f</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</code>, la cual devuelve una expresi&oacute;n con el mismo operador principal que tenga <var>expr_i</var>, excepto en simplificaciones y en el caso en el que <code>map</code> hace un <code>apply</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>prederror</b>
<a name="IDX1348"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>prederror</code> toma el valor <code>true</code>, se emite un mensaje de error siempre que el predicado de una sentencia  <code>if</code> o de una funci&oacute;n <code>is</code> no se pueda evaluar ni a verdadero (<code>true</code>) ni  a falso (<code>false</code>).
</p>
<p>Si toma el valor <code>false</code>, se devuelve bajo las mismas circunstancias anteriores el valor <code>unknown</code>. El modo <code>prederror: false</code> no est&aacute; soportado en el c&oacute;digo traducido; sin embargo, <code>maybe</code> est&aacute; soportado en c&oacute;digo traducido.
</p>
<p>V&eacute;anse tambi&eacute;n <code>is</code> y <code>maybe</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>return</b><i> (valor)</i>
<a name="IDX1349"></a>
</dt>
<dd><p>Puede utilizarse para salir de un bloque, devolviendo su.  V&eacute;ase <code>block</code> para m&aacute;s informaci&oacute;n.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>)</i>
<a name="IDX1350"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>scanmap</b><i> (<var>f</var>, <var>expr</var>, bottomup)</i>
<a name="IDX1351"></a>
</dt>
<dd><p>Aplica recursivamente <var>f</var> sobre <var>expr</var>, de arriba hacia abajo. Esto es m&aacute;s &uacute;til cuando se busca una factorizaci&oacute;n completa, por ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
</pre></td></tr></table>
<p>N&oacute;tese que c&oacute;mo <code>scanmap</code> aplica la funci&oacute;n dada <code>factor</code> a las subexpresiones que forman a <var>expr</var>; si se presenta otra forma de <var>expr</var> a <code>scanmap</code> entonces el resultado puede ser diferente. As&iacute;, <code>%o2</code> no se restaura cuando <code>scanmap</code> se aplica a la forma expandida de exp:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
</pre></td></tr></table>
<p>Aqu&iacute; hay otro ejemplo de la forma en que <code>scanmap</code> aplica recursivamente una funci&oacute;n dada a todas las subexpresiones, incluyendo exponentes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
</pre></td></tr></table>
<p><code>scanmap (<var>f</var>, <var>expr</var>, bottomup)</code> aplica <var>f</var> a <var>expr</var> de abajo hacia arriba. Por ejemplo, para <code>f</code> no definida,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">scanmap(f,a*x+b) -&gt;
   f(a*x+b) -&gt; f(f(a*x)+f(b)) -&gt; f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -&gt; f(a)*f(x)+f(b)
    -&gt; f(f(a)*f(x))+f(b) -&gt;
     f(f(f(a)*f(x))+f(b))
</pre></td></tr></table>
<p>En este caso se obtiene la misma respuesta por cualquiera de los dos m&eacute;todos.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>throw</b><i> (<var>expr</var>)</i>
<a name="IDX1352"></a>
</dt>
<dd><p>Eval&uacute;a <var>expr</var> y devuelve el valor del <code>catch</code> m&aacute;s reciente. La funci&oacute;n <code>throw</code> se utiliza junto con <code>catch</code> como un mecanismo de retorno no local.
</p>
</dd></dl>


<dl>
<dt><u>Operador especial:</u> <b>while</b>
<a name="IDX1353"></a>
</dt>
<dd><p>V&eacute;ase <code>do</code>.
</p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>outermap</b><i> (<var>f</var>, <var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1354"></a>
</dt>
<dd><p>Aplica la funci&oacute;n <var>f</var> a cada uno de los elementos del producto vectorial <var>a_1</var> por <var>a_2</var> ... por <var>a_n</var>.
</p>
<p>El argumento <var>f</var> debe ser el nombre de una funci&oacute;n de <em>n</em> argumentos,
o una expresi&oacute;n lambda de <em>n</em> argumentos.
Cada uno de los argumentos <var>a_k</var> puede ser una lista, una lista anidada, 
una matriz o cualquier otro tipo de expresi&oacute;n.
</p>
<p>El valor devuelto por <code>outermap</code> es una estructura anidada. Si <var>x</var> es la
respuesta dada por <code>outermap</code>, entonces tiene la misma estructura que la primera lista,
lista anidada o matriz, <code><var>x</var>[i_1]...[i_m]</code> tiene la misma estructura que la
segunda lista, lista anidada o matriz, <code><var>x</var>[i_1]...[i_m][j_1]...[j_n]</code> tiene 
la misma estructura que la tercera lista, lista anidada o matriz, y as&iacute;
sucesivamente, siendo <var>m</var>, <var>n</var>, ... los n&uacute;meros &iacute;ndice
necesarios para acceder a los elementos de cada argumento: uno para las listas,
dos para las matrices y uno o m&aacute;s para las listas anidadas. 
Aquellos argumentos que no sean listas ni matrices no tienen efecto alguno sobre
la estructura del valor retornado.
</p>
<p>N&oacute;tese que el efecto producido por <code>outermap</code> es diferente del que
se obtiene al aplicar <var>f</var> a cada uno de los elementos del producto
devuelto por <code>cartesian_product</code>. La funci&oacute;n <code>outermap</code>
mantiene la estructura de los argumentos en la respuesta, miemtras que
<code>cartesian_product</code> no lo hace.
</p>
<p>La funci&oacute;n <code>outermap</code> eval&uacute;a sus argumentos.
</p>
<p>V&eacute;anse tambi&eacute;n <code>map</code>, <code>maplist</code> y <code>apply</code>.
</p>
<p>Ejemplos:
</p>
<p>Ejemplos elementales de uso de <code>outermap</code>.
Con el fin de mostrar con mayor claridad las combinaciones del argumento,
se mantiene sin definir <code>F</code>.
</p>

<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
         [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
(%o2)    [                                            ]
         [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
(%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
       [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
(%o3) [[                        ], [                        ]]
       [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
(%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
       [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
(%o4) [[ [            ]  [            ] ], 
       [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                              [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                              [ [            ]  [            ] ]]
                              [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
(%i5) outermap (&quot;+&quot;, [a, b, c], [1, 2, 3]);
(%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3], 
                                           [c + 1, c + 2, c + 3]]
</pre></td></tr></table>
<p>El siguiente ejemplo permite hacer un an&aacute;lisis m&aacute;s profundo del valor
retornado por <code>outermap</code>.
Los tres primeros argumentos son una matriz, una lista y otra matriz, en este
orden. El valor devuelto es una matriz, cuyos elementos son listas y
cada elemento de cada una de estas listas es a su vez una matriz.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) arg_1 :  matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) arg_2 : [11, 22];
(%o2)                       [11, 22]
(%i3) arg_3 : matrix ([xx, yy]);
(%o3)                      [ xx  yy ]
(%i4) xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
               [  [      a        a  ]  [      a        a  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
(%o4)  Col 1 = [                                              ]
               [  [      c        c  ]  [      c        c  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
                 [  [      b        b  ]  [      b        b  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
         Col 2 = [                                              ]
                 [  [      d        d  ]  [      d        d  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
(%i5) xx_1 : xx_0 [1][1];
           [      a        a  ]  [      a        a  ]
(%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
           [      11       11 ]  [      22       22 ]
(%i6) xx_2 : xx_0 [1][1] [1];
                      [      a        a  ]
(%o6)                 [ xx + --  yy + -- ]
                      [      11       11 ]
(%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                  a
(%o7)                        xx + --
                                  11
(%i8) [op (arg_1), op (arg_2), op (arg_3)];
(%o8)                  [matrix, [, matrix]
(%i9) [op (xx_0), op (xx_1), op (xx_2)];
(%o9)                  [matrix, [, matrix]
</pre></td></tr></table>
<p>La funci&oacute;n <code>outermap</code> mantiene la estructura de los argumentos en su respuesta,
mientras que <code>cartesian_product</code> no lo hace.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) setify (flatten (%));
(%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
(%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)}
(%i4) is (equal (%, %th (2)));
(%o4)                         true
</pre></td></tr></table>
</dd></dl>




<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC157" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_41.html#SEC160" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>mayo, 2 2007</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
