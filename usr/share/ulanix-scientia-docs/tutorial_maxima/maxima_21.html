<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on mayo, 2 2007 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima: 21. Ecuaciones</title>

<meta name="description" content="Manual de Maxima: 21. Ecuaciones">
<meta name="keywords" content="Manual de Maxima: 21. Ecuaciones">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,180); /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    font-family: "Lucida Console", monospace
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}
-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Ecuaciones"></a>
<a name="SEC69"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_20.html#SEC68" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_20.html#SEC63" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC71" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 21. Ecuaciones </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC70">21.1 Definiciones para Ecuaciones</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Definiciones-para-Ecuaciones"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC69" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC71" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC69" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC69" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC71" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC70"></a>
<h2 class="section"> 21.1 Definiciones para Ecuaciones </h2>

<dl>
<dt><u>Variable del sistema:</u> <b>%rnum_list</b>
<a name="IDX639"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>%rnum_list</code> es la lista de variables introducidas en las soluciones por la funci&oacute;n <code>algsys</code>.
Las variables <code>%r</code> se a&ntilde;aden a <code>%rnum_list</code> en su orden de creaci&oacute;n. Esto es &uacute;til para hacer sustituciones en la soluci&oacute;n.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>algexact</b>
<a name="IDX640"></a>
</dt>
<dd><p>Default value: <code>false</code>
</p>
<p>El contenido de la variable <code>algexact</code> afecta al comportamiento de <code>algsys</code> de la siguiente forma:
</p>
<p>Si <code>algexact</code> vale <code>true</code>, <code>algsys</code> llamar&aacute; siempre a <code>solve</code> y luego utilizar&aacute; <code>realroots</code>.
</p>
<p>Si <code>algexact</code> vale <code>false</code>, <code>solve</code> ser&aacute; llamada s&oacute;lo si la ecuaci&oacute;n no es univariante, o si es cuadr&aacute;tica o bicuadr&aacute;tica.
</p>
<p>Sin embargo, <code>algexact: true</code> no garantiza que &uacute;nicamente se obtengan soluciones exactas, ya que aunque <code>algsys</code> intente siempre dar soluciones exactas, dar&aacute; resultados aproximados si no encuentra una soluci&oacute;n mejor.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>algsys</b><i> ([<var>expr_1</var>, ..., <var>expr_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX641"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>algsys</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX642"></a>
</dt>
<dd><p>Resuelve el sistema de ecuaciones polin&oacute;micas <var>expr_1</var>, ..., <var>expr_m</var>
o las ecuaciones <var>eqn_1</var>, ..., <var>eqn_m</var> para las variables <var>x_1</var>, ..., <var>x_n</var>.
La expresi&oacute;n <var>expr</var> equivale a la ecuaci&oacute;n <code><var>expr</var> = 0</code>. Puede haber m&aacute;s ecuaciones que variables o viceversa.
</p>
<p>La funci&oacute;n <code>algsys</code> devuelve una lista de soluciones, cada una de las cuales consistente a su vez en una lista de ecuaciones asociando valores a las variables <var>x_1</var>, ..., <var>x_n</var> que satisfacen el sistema de ecuaciones.
Si <code>algsys</code> no puede encontrar soluciones devuelve la lista vac&iacute;a <code>[]</code>.
</p>
<p>Si es necesario se introducen en la soluci&oacute;n los s&iacute;mbolos  <code>%r1</code>, <code>%r2</code>, ..., para representar par&aacute;metros arbitrarios; estas variables tambi&eacute;n se a&ntilde;aden a la lista <code>%rnum_list</code>.
</p>
<p>El proceso que se sigue es el siguiente:
</p>
<p>(1) Primero se factorizan las ecuaciones y se reparten en subsistemas.
</p>
<p>(2) Para cada subsistema <var>S_i</var>, se seleccionan una ecuaci&oacute;n <var>E</var> y una variable <var>x</var>. Se elige la variable que tenga grado menor. Entonces se calcula el resultado de <var>E</var> y <var>E_j</var> respecto de <var>x</var>, siendo las <var>E_j</var> el resto de ecuaciones del subsistema <var>S_i</var>. De aqu&iacute; se obtiene otro subsistema <var>S_i'</var> con una inc&oacute;gnita menos, ya que <var>x</var> ha sido eliminada. El proceso ahora vuelve al paso (1).
</p>
<p>(3) En ocasiones se obtiene un subsistema consistente en una &uacute;nica ecuaci&oacute;n. Si la ecuaci&oacute;n es multivariante y no se han introducido aproximaciones en formato decimal de coma flotante, entonces  se llama a <code>solve</code> para tratar de encontrar una soluci&oacute;n exacta.
</p>
<p>En algunos casos, <code>solve</code> no puede encontrar la soluci&oacute;n, o si lo consigue puede que el resultado tenga una expresi&oacute;n muy grande.
</p>
<p>Si la ecuaci&oacute;n tiene una s&oacute;la inc&oacute;gnita y es lineal, o cuadr&aacute;tica o bicuadr&aacute;tica, entonces se llama a la funci&oacute;n <code>solve</code> si no se han introducido aproximaciones en formato decimal. Si se han introducido aproximaciones, o si hay m&aacute;s de una inc&oacute;gnita, o si no es lineal, ni cuadr&aacute;tica ni bicuadr&aacute;tica, y si la variables <code>realonly</code> vale <code>true</code>, entonces se llama a la funci&oacute;n <code>realroots</code> para calcular las soluciones reales.  Si
<code>realonly</code> vale <code>false</code>, entonces se llama a <code>allroots</code> para obtener las soluciones reales y complejas.
</p>
<p>Si <code>algsys</code> devuelve una soluci&oacute;n que tiene menos d&iacute;gitos significativos de los requeridos, el usuario puede cambiar a voluntad el valor de <code>algepsilon</code> para obtener mayor precisi&oacute;n.
</p>
<p>Si <code>algexact</code> vale <code>true</code>, se llamar&aacute; siempre a <code>solve</code>.
</p>
<p>Cuando <code>algsys</code> encuentra una ecuaci&oacute;n con m&uacute;ltiples inc&oacute;gnitas y que contiene aproximaciones en coma flotante (normalmente debido a la imposibilidad de encontrar soluciones exactas en pasos anteriores), entonces no intenta aplicar los m&eacute;todos exactos a estas ecuaciones y presenta el mensaje: 
&quot;<code>algsys</code> cannot solve - system too complicated.&quot;
</p>
<p>Las interacciones con <code>radcan</code> pueden dar lugar a expresiones grandes o complicadas. En tal caso, puede ser posible aislar partes del resultado con  <code>pickapart</code> o <code>reveal</code>.
</p>
<p>Ocasionalmente, <code>radcan</code> puede introducir la unidad imaginaria <code>%i</code> en una soluci&oacute;n que de hecho es real.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>allroots</b><i> (<var>expr</var>)</i>
<a name="IDX643"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>allroots</b><i> (<var>eqn</var>)</i>
<a name="IDX644"></a>
</dt>
<dd><p>Calcula aproximaciones num&eacute;ricas de las ra&iacute;ces reales y complejas del polinomio <var>expr</var> o ecuaci&oacute;n polin&oacute;mica <var>eqn</var> de una variable.
</p>
<p>Si la variable <code>polyfactor</code> vale <code>true</code> hace que la funci&oacute;n 
<code>allroots</code> factorice el polinomio para n&uacute;meros reales si el polinomio es real, o para n&uacute;meros complejos si el polinomio es complejo.
</p>
<p>La funci&oacute;n <code>allroots</code> puede dar resultados inexactos en caso de que haya ra&iacute;ces m&uacute;ltiples.
Si el polinomio es real, <code>allroots (%i*<var>p</var>)</code>) puede alcanzar mejores aproximaciones que <code>allroots (<var>p</var>)</code>,
ya que <code>allroots</code> ejecuta entonces un algoritmo diferente.
</p>
<p>La funci&oacute;n <code>allroots</code> no opera sobre expresiones no polin&oacute;micas, pues requiere que el numerador sea reducible a un polinomio y el denominador sea, como mucho, un n&uacute;mero complejo. 
</p>
<p>Para polinomios complejos se utiliza el algoritmo de Jenkins y Traub descrito en (Algorithm 419, <i>Comm. ACM</i>, vol. 15, (1972), p. 97). Para polinomios reales se utiliza el algoritmo de Jenkins descrito en (Algorithm 493, <i>ACM TOMS</i>,
vol. 1, (1975), p.178).
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
</pre></td></tr></table>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>breakup</b>
<a name="IDX645"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>breakup</code> vale <code>true</code>, <code>solve</code> expresa sus soluciones a las ecuaciones c&uacute;bicas y cu&aacute;rticas en t&eacute;rminos de subexpresiones comunes, las cuales son asignadas a etiquetas del tipo <code>%t1</code>, <code>%t2</code>, etc.
En otro caso, no se identifican subexpresiones comunes.
</p>
<p>La asignaci&oacute;n <code>breakup: true</code> s&oacute;lo tiene efecto cuando <code>programmode</code> vale <code>false</code>.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>dimension</b><i> (<var>eqn</var>)</i>
<a name="IDX646"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>dimension</b><i> (<var>eqn_1</var>, ..., <var>eqn_n</var>)</i>
<a name="IDX647"></a>
</dt>
<dd><p>El paquete <code>dimen</code> es para an&aacute;lisis dimensional. La instrucci&oacute;n <code>load (&quot;dimen&quot;)</code> carga el paquete y
<code>demo (&quot;dimen&quot;)</code> presenta una peque&ntilde;a demostraci&oacute;n.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dispflag</b>
<a name="IDX648"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>dispflag</code> vale <code>false</code>, entonces se inhibir&aacute; que Maxima muestre resultados de las funciones que resuelven ecuaciones cuando &eacute;stas son llamadas desde dentro de un bloque (<code>block</code>). Cuando un bloque termina con el signo del d&oacute;lar, $, a la variable <code>dispflag</code> se le asigna <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>funcsolve</b><i> (<var>eqn</var>, <var>g</var>(<var>t</var>))</i>
<a name="IDX649"></a>
</dt>
<dd><p>Devuelve <code>[<var>g</var>(<var>t</var>) = ...]</code>  o <code>[]</code>, dependiendo de que exista o no una funci&oacute;n racional  <code><var>g</var>(<var>t</var>)</code> que satisfaga <var>eqn</var>, la cual debe ser un polinomio de primer orden, lineal para <code><var>g</var>(<var>t</var>)</code> y <code><var>g</var>(<var>t</var>+1)</code>
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Dependent equations eliminated:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
</pre></td></tr></table>
<p>Aviso: esta es una implemetaci&oacute;n rudimentaria, por lo que debe ser utilizada con cautela.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>globalsolve</b>
<a name="IDX650"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>globalsolve</code> vale <code>true</code>,
a las inc&oacute;gnitas de las ecuaciones se les asignan las soluciones encontradas por <code>linsolve</code> y
por <code>solve</code> cuando se resuelven sistemas de dos o m&aacute;s ecuaciones lineales.
</p>
<p>Si <code>globalsolve</code> vale <code>false</code>,
las soluciones encontradas por <code>linsolve</code> y por <code>solve</code> cuando se resuelven sistemas de dos o m&aacute;s ecuaciones lineales se expresan como ecuaciones y a las inc&oacute;gnitas no se le asignan valores.
</p>
<p>Cuando se resuelven ecuaciones que no son sistemas de dos o m&aacute;s ecuaciones lineales, <code>solve</code> ignora el valor de <code>globalsolve</code>. Otras funciones que resuelven ecuaciones (como <code>algsys</code>) ignoran siempre el valor de <code>globalsolve</code>.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>ieqn</b><i> (<var>ie</var>, <var>unk</var>, <var>tech</var>, <var>n</var>, <var>guess</var>)</i>
<a name="IDX651"></a>
</dt>
<dd><p>El paquete <code>inteqn</code> se dedica a la resoluci&oacute;n de ecuaciones integrales. Para hacer uso de &eacute;l, ejecutar la instrucci&oacute;n <code>load (&quot;inteqn&quot;)</code>.
</p>
<p>El argumento <var>ie</var> es la ecuaci&oacute;n integral; <var>unk</var> es la funci&oacute;n inc&oacute;gnita; <var>tech</var> es el m&eacute;todo a aplicar para efectuar la resoluci&oacute;n del problema (<var>tech</var> = <code>first</code> significa: aplica el primer m&eacute;todo que encuentre una soluci&oacute;n; <var>tech</var> = <code>all</code> significa: aplica todos los m&eacute;todos posibles); <var>n</var> es el n&uacute;mero m&aacute;ximo de t&eacute;rminos que debe tomar <code>taylor</code>, <code>neumann</code>, <code>firstkindseries</code> o <code>fredseries</code> (tambi&eacute;n es el m&aacute;ximo nivel de recursi&oacute;n para el m&eacute;todo de diferenciaci&oacute;n); <var>guess</var> es la soluci&oacute;n candidata inicial para <code>neumann</code> o <code>firstkindseries</code>.
</p>
<p>Valores por defecto para los argumentos segundo a quinto son:
</p>
<p><var>unk</var>: <code><var>p</var>(<var>x</var>)</code>, donde <var>p</var> es la primera funci&oacute;n desconocida que Maxima encuentra en el integrando y <var>x</var> es la variable que act&uacute;a como argumento en la primera aparici&oacute;n de <var>p</var> encontrada fuera de una integral en el caso de ecuaciones de segunda especie (<code>secondkind</code>), o es la &uacute;nica variable aparte de la de integraci&oacute;n en el caso de ecuaciones de primera especie (<code>firstkind</code>). Si el intento de encontrar <var>x</var> falla, el usuario ser&aacute; consultado para suministrar una variable independiente.
</p>

</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>ieqnprint</b>
<a name="IDX652"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>ieqnprint</code> controla el comportamiento del resultado retornado por la instrucci&oacute;n <code>ieqn</code>. Si <code>ieqnprint</code> vale <code>false</code>, la lista devuelta por la funci&oacute;n <code>ieqn</code> tiene el formato
</p>
<p>   [<var>soluci&oacute;n</var>, <var>m&eacute;todo utilizado</var>, <var>nterms</var>, <var>variable</var>]
</p>
<p>donde <var>variable</var> estar&aacute; ausente si la soluci&oacute;n es exacta; en otro caso, ser&aacute; la palabra <code>approximate</code> o <code>incomplete</code> seg&uacute;n que la soluci&oacute;n sea inexacta o que no tenga forma expl&iacute;cita, respectivamente. Si se ha utilizado un m&eacute;todo basado en series, <var>nterms</var> es el n&uacute;mero de t&eacute;rminos utilizado, que puede ser menor que el <code>n</code> dado a <code>ieqn</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>lhs</b><i> (<var>expr</var>)</i>
<a name="IDX653"></a>
</dt>
<dd><p>Devuelve el miembro izquierdo (es decir, el primer argumento)
de la expresi&oacute;n <var>expr</var>,
cuando el operador de <var>expr</var> es uno de los operadores
de relaci&oacute;n <code>&lt; &lt;= = # equal notequal &gt;= &gt;</code>,
o un operadores de asignaci&oacute;n <code>:= ::= : ::</code>,
o un operador infijo binario definido por el usuario mediante <code>infix</code>.
</p>
<p>Si <var>expr</var> es un &aacute;tomo o si su operador es diferente de los
citados m&aacute;s arriba, <code>lhs</code> devuelve <var>expr</var>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>rhs</code>.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [lhs (aa &lt; bb), lhs (aa &lt;= bb), lhs (aa &gt;= bb), lhs (aa &gt; bb)];
(%o4)                   [aa, aa, aa, aa]
(%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
(%o5)                   [aa, aa, aa, aa]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
(%o10)               [foo(x), bar(y), x, x]
(%i11) infix (&quot;][&quot;);
(%o11)                         ][
(%i12) lhs (aa ][ bb);
(%o12)                         aa
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>linsolve</b><i> ([<var>expr_1</var>, ..., <var>expr_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX654"></a>
</dt>
<dd><p>Resuelve la lista de ecuaciones lineales simult&aacute;neas para la lista de variables. Las expresiones deben ser polinomios lineales respecto de las variables o ecuaciones.
</p>
<p>Si <code>globalsolve</code> vale <code>true</code>,
a cada inc&oacute;gnita se le asigna el valor de la soluci&oacute;n encontrada.
</p>
<p>Si <code>backsubst</code> vale <code>false</code>, <code>linsolve</code>
no hace la sustituci&oacute;n tras la triangulariaci&oacute;n de las ecuaciones. 
Esto puede ser necesario en problemas muy grandes en los que la
sustituci&oacute;n puede dar lugar a la generaci&oacute;n de expresiones
enormes.
</p>
<p>Si <code>linsolve_params</code> vale <code>true</code>, <code>linsolve</code> tambi&eacute;n genera s&iacute;mbolos <code>%r</code> para representar par&aacute;metros arbitrarios como los descritos para la funci&oacute;n <code>algsys</code>. Si vale <code>false</code>, el resultado devuelto por <code>linsolve</code> expresar&aacute;, si es el sistema es indeterminado, unas variables en funci&oacute;n de otras.
</p>
<p>Si <code>programmode</code> vale <code>false</code>,
<code>linsolve</code> muestra la soluci&oacute;n con etiquetas de expresiones 
intermedias (<code>%t</code>) y devuelve las lista de etiquetas.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) e1: x + z = y;
(%o1)                       z + x = y
(%i2) e2: 2*a*x - y = 2*a^2;
                                       2
(%o2)                   2 a x - y = 2 a
(%i3) e3: y - 2*z = 2;
(%o3)                      y - 2 z = 2
(%i4) [globalsolve: false, programmode: true];
(%o4)                     [false, true]
(%i5) linsolve ([e1, e2, e3], [x, y, z]);
(%o5)            [x = a + 1, y = 2 a, z = a - 1]
(%i6) [globalsolve: false, programmode: false];
(%o6)                    [false, false]
(%i7) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t7)                       z = a - 1

(%t8)                        y = 2 a

(%t9)                       x = a + 1
(%o9)                    [%t7, %t8, %t9]
(%i9) ''%;
(%o9)            [z = a - 1, y = 2 a, x = a + 1]
(%i10) [globalsolve: true, programmode: false];
(%o10)                    [true, false]
(%i11) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t11)                      z : a - 1

(%t12)                       y : 2 a

(%t13)                      x : a + 1
(%o13)                 [%t11, %t12, %t13]
(%i13) ''%;
(%o13)           [z : a - 1, y : 2 a, x : a + 1]
(%i14) [x, y, z];
(%o14)                 [a + 1, 2 a, a - 1]
(%i15) [globalsolve: true, programmode: true];
(%o15)                    [true, true]
(%i16) linsolve ([e1, e2, e3], '[x, y, z]);
(%o16)           [x : a + 1, y : 2 a, z : a - 1]
(%i17) [x, y, z];
(%o17)                 [a + 1, 2 a, a - 1]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>linsolvewarn</b>
<a name="IDX655"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>linsolvewarn</code> vale <code>true</code>, <code>linsolve</code> mostrar&aacute; el mensaje: &quot;Dependent equations eliminated&quot;.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>linsolve_params</b>
<a name="IDX656"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>linsolve_params</code> vale <code>true</code>, <code>linsolve</code> tambi&eacute;n genera s&iacute;mbolos <code>%r</code> para representar par&aacute;metros arbitrarios como los descritos para la funci&oacute;n <code>algsys</code>. Si vale <code>false</code>, el resultado devuelto por <code>linsolve</code> expresar&aacute;, si es el sistema es indeterminado, unas variables en funci&oacute;n de otras.
</p>
</dd></dl>

<dl>
<dt><u>System variable:</u> <b>multiplicities</b>
<a name="IDX657"></a>
</dt>
<dd><p>Valor por defecto: <code>not_set_yet</code>
</p>
<p>La variable <code>multiplicities</code> es una con las multiplicidades de las soluciones encontradas por <code>solve</code> o
<code>realroots</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>nroots</b><i> (<var>p</var>, <var>low</var>, <var>high</var>)</i>
<a name="IDX658"></a>
</dt>
<dd><p>Devuelve el n&uacute;mero de ra&iacute;ces reales del polinomio real univariante <var>p</var> en el intervalo semiabierto
<code>(<var>low</var>, <var>high</var>]</code>. Los extremos del intervalo pueden ser <code>minf</code> o <code>inf</code>, menos y m&aacute;s infinito.
</p>
<p>La funci&oacute;n <code>nroots</code> utiliza el m&eacute;todo de las secuencias de Sturm.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>nthroot</b><i> (<var>p</var>, <var>n</var>)</i>
<a name="IDX659"></a>
</dt>
<dd><p>Siendo <code>p</code> un polinomio de coeficientes enteros y <code>n</code> un entero positivo, <code>nthroot</code> devuelve un polinomio <code>q</code>, tambi&eacute;n de coeficientes enteros, tal que <code>q^n=p</code>, o un mensaje de error indicando que <code>p</code> no es una <code>n</code>-potencia exacta. Esta funci&oacute;n es bastante m&aacute;s r&aacute;pida que <code>factor</code> y que <code>sqfr</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>programmode</b>
<a name="IDX660"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>programmode</code> vale <code>true</code>, <code>solve</code>, <code>realroots</code>, <code>allroots</code> y <code>linsolve</code>
devuelve sus soluciones como elementos de una lista. </p>
<p>Si <code>programmode</code> vale <code>false</code>, <code>solve</code> y las dem&aacute;s crean expresiones intermedias etiquetadas <code>%t1</code>, <code>t2</code>, etc., y les asinan las soluciones.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) solve(x^2+x+1);
                    sqrt(3) %i + 1      sqrt(3) %i - 1
(%o1)        [x = - --------------, x = --------------]
                          2                   2
(%i2) programmode:false$
(%i3) solve(x^2+x+1);
Solution:

                              sqrt(3) %i + 1
(%t3)                   x = - --------------
                                    2

                             sqrt(3) %i - 1
(%t4)                    x = --------------
                                   2
(%o4)                        [%t4, %t5]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>realonly</b>
<a name="IDX661"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>realonly</code> vale <code>true</code>, <code>algsys</code> s&oacute;lo devuelve aquellas soluciones exentas de la constante <code>%i</code>.
</p>
</dd></dl>


<dl>
<dt><u>Funci&oacute;n:</u> <b>realroots</b><i> (<var>expr</var>, <var>bound</var>)</i>
<a name="IDX662"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>realroots</b><i> (<var>eqn</var>, <var>bound</var>)</i>
<a name="IDX663"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>realroots</b><i> (<var>expr</var>)</i>
<a name="IDX664"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>realroots</b><i> (<var>eqn</var>)</i>
<a name="IDX665"></a>
</dt>
<dd><p>Calcula aproximaciones racionales de las ra&iacute;ces reales del
polinomio <var>expr</var> o de la ecuaci&oacute;n polin&oacute;mica <var>eqn</var> de una variable,
dentro de la tolerancia especificada por <var>bound</var>.
Los coeficientes de <var>expr</var> o de <var>eqn</var> deben ser n&uacute;meros literales,
por lo que las constantes simb&oacute;licas como <code>%pi</code> no son aceptadas.
</p>
<p>La funci&oacute;n <code>realroots</code> guarda las multiplicidades de las
ra&iacute;ces encontradas en la variable global <code>multiplicities</code>.
</p>
<p>La funci&oacute;n <code>realroots</code> genera una secuencia de Sturm para acotar cada
ra&iacute;z, aplicando despu&eacute;s el m&eacute;todo de bisecci&oacute;n para
afinar las aproximaciones. Todos los coeficientes se convierten a formas
racionales equivalentes antes de comenzar la b&uacute;squeda de las ra&iacute;ces,
de modo que los c&aacute;lculos se realizan con aritm&eacute;tica exacta racional. Incluso en
el caso de que algunos coeficientes sean n&uacute;meros decimales en coma flotante, los
resultados son racionales, a menos que se les fuerce a ser decimales con las variables
<code>float</code> o <code>numer</code>.
</p>
<p>Si <var>bound</var> es menor que la unidad, todas las ra&iacute;ces enteras se expresan
en forma exacta. Si no se especifica <var>bound</var>, se le supone igual al valor de la
variable global <code>rootsepsilon</code>.
</p>
<p>Si la variable global <code>programmode</code> vale <code>true</code>, la funci&oacute;n 
<code>realroots</code> devuelve una lista de la forma <code>[x = <var>x_1</var>, x = <var>x_2</var>, ...]</code>.
Si <code>programmode</code> vale <code>false</code>, <code>realroots</code> crea etiquetas 
<code>%t1</code>, <code>%t2</code>, ... para las expresiones intermedias, les asigna valores y, finalmente,
devuelve la lista de etiquetas.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) realroots (-1 - x + x^5, 5e-6);
                               612003
(%o1)                     [x = ------]
                               524288
(%i2) ev (%[1], float);
(%o2)                 x = 1.167303085327148
(%i3) ev (-1 - x + x^5, %);
(%o3)                - 7.396496210176905E-6
</pre></td></tr></table>

<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
(%o1)                 [x = 1, x = 2, x = 3]
(%i2) multiplicities;
(%o2)                       [5, 3, 1]
</pre></td></tr></table>
</dd></dl>



<dl>
<dt><u>Funci&oacute;n:</u> <b>rhs</b><i> (<var>expr</var>)</i>
<a name="IDX666"></a>
</dt>
<dd><p>Devuelve el miembro derecho (es decir, el segundo argumento)
de la expresi&oacute;n <var>expr</var>,
cuando el operador de <var>expr</var> es uno de los operadores
de relaci&oacute;n <code>&lt; &lt;= = # equal notequal &gt;= &gt;</code>,
o un operadores de asignaci&oacute;n <code>:= ::= : ::</code>,
o un operador infijo binario definido por el usuario mediante <code>infix</code>.
</p>
<p>Si <var>expr</var> es un &aacute;tomo o si su operador es diferente de los
citados m&aacute;s arriba, <code>rhs</code> devuelve <var>expr</var>.
</p>
<p>V&eacute;ase tambi&eacute;n <code>lhs</code>.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [rhs (aa &lt; bb), rhs (aa &lt;= bb), rhs (aa &gt;= bb), rhs (aa &gt; bb)];
(%o4)                   [bb, bb, bb, bb]
(%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
(%o5)                   [bb, bb, bb, bb]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
(%o10)                  [2 x, 3 y, y, y]
(%i11) infix (&quot;][&quot;);
(%o11)                         ][
(%i12) rhs (aa ][ bb);
(%o12)                         bb
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>rootsconmode</b>
<a name="IDX667"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>rootsconmode</code> controla el comportamiento de la instrucci&oacute;n <code>rootscontract</code>.  V&eacute;ase <code>rootscontract</code> para m&aacute;s detalles.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>rootscontract</b><i> (<var>expr</var>)</i>
<a name="IDX668"></a>
</dt>
<dd><p>Convierte productos de ra&iacute;ces en ra&iacute;ces de productos. Por ejemplo, <code>rootscontract (sqrt(x)*y^(3/2))</code> devuelve <code>sqrt(x*y^3)</code>.
</p>
<p>Si <code>radexpand</code> vale <code>true</code> y <code>domain</code> vale <code>real</code>,
<code>rootscontract</code> convierte <code>abs</code> en <code>sqrt</code>, por ejemplo,
<code>rootscontract (abs(x)*sqrt(y))</code> devuelve <code>sqrt(x^2*y)</code>.
</p>
<p>La opci&oacute;n <code>rootsconmode</code> afecta el resultado de <code>rootscontract</code> como sigue:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">Problema            Valor de         Resultadod de
                  rootsconmode        rootscontract
      
x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)
</pre></td></tr></table>
<p>Si <code>rootsconmode</code> vale <code>false</code>, <code>rootscontract</code> contrae s&oacute;lamente respecto de exponentes racionales cuyos denominadores sean iguales. La clave para los ejemplos <code>rootsconmode: true</code> es simplemente que 2 divide a 4 pero no a 3. La asignaci&oacute;n <code>rootsconmode: all</code> hace que se calcule el m&iacute;nimo com&uacute;n m&uacute;ltiplo de los denominadores de los exponentes.
</p>
<p>La funci&oacute;n <code>rootscontract</code> utiliza <code>ratsimp</code> de forma similar a como lo hace <code>logcontract</code>.
</p>
<p>Ejemplos:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) rootsconmode: false$
(%i2) rootscontract (x^(1/2)*y^(3/2));
                                   3
(%o2)                      sqrt(x y )
(%i3) rootscontract (x^(1/2)*y^(1/4));
                                   1/4
(%o3)                     sqrt(x) y
(%i4) rootsconmode: true$
(%i5) rootscontract (x^(1/2)*y^(1/4));
(%o5)                    sqrt(x sqrt(y))
(%i6) rootscontract (x^(1/2)*y^(1/3));
                                   1/3
(%o6)                     sqrt(x) y
(%i7) rootsconmode: all$
(%i8) rootscontract (x^(1/2)*y^(1/4));
                              2   1/4
(%o8)                       (x  y)
(%i9) rootscontract (x^(1/2)*y^(1/3));
                             3  2 1/6
(%o9)                      (x  y )
(%i10) rootsconmode: false$
(%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                    *sqrt(sqrt(1 + x) - sqrt(x)));
(%o11)                          1
(%i12) rootsconmode: true$
(%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
(%o13)                          0
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>rootsepsilon</b>
<a name="IDX669"></a>
</dt>
<dd><p>Valor por defecto: 1.0e-7
</p>
<p>La variable <code>rootsepsilon</code> es la tolerancia que establece el intervalo de confianza para las ra&iacute;ces calculadas por la funci&oacute;n <code>realroots</code>.
</p>
</dd></dl>

<dl>
<dt><u>Funci&oacute;n:</u> <b>solve</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX670"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>solve</b><i> (<var>expr</var>)</i>
<a name="IDX671"></a>
</dt>
<dt><u>Funci&oacute;n:</u> <b>solve</b><i> ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX672"></a>
</dt>
<dd><p>Resuelve la ecuaci&oacute;n algebraica <var>expr</var> de inc&oacute;gnita <var>x</var> y devuelve una lista de igualdades con la <var>x</var> despejada.  Si <var>expr</var> no es una igualdad, se supone que se quiere resolver la ecuaci&oacute;n <code><var>expr</var> = 0</code>.
El argumento <var>x</var> puede ser una funci&oacute;n (por ejemplo, <code>f(x)</code>), u otra expresi&oacute;n no at&oacute;mica, excepto una suma o producto. Puede omitirse <var>x</var> si <var>expr</var> contiene solamente una variable. El argumento <var>expr</var> puede ser una expresi&oacute;n racional y puede contener funciones trigonom&eacute;tricas, exponenciales, etc.
</p>
<p>Se utiliza el siguiente m&eacute;todo de resoluci&oacute;n:
</p>
<p>Sea <var>E</var> la expresi&oacute;n y <var>X</var> la inc&oacute;gnita. Si <var>E</var> es lineal respecto de <var>X</var> entonces <var>X</var> se resuelve de forma trivial. En caso contrario, si <var>E</var> es de la forma <code>A*X^N + B</code> entonces el resultado es <code>(-B/A)^1/N)</code> multiplicado por las <code>N</code>-&eacute;simas ra&iacute;ces de la unidad.
</p>
<p>Si <var>E</var> no es lineal respecto de <var>X</var> entonces el m&aacute;ximo com&uacute;n divisor de los exponentes de <var>X</var> en <var>E</var> (sup&oacute;ngase que es <var>N</var>) se divide entre los exponentes y la multiplicidad de las ra&iacute;ces se multiplica por <var>N</var>.  Entonces es llamado recursivamente <code>solve</code> para este resultado. Si <var>E</var> es factorizable entonces <code>solve</code> es invocado para cada uno de los factores.  Finalmente, <code>solve</code> usar&aacute;, seg&uacute;n sea necesario, las f&oacute;rmulas cuadr&aacute;tica, c&uacute;bica o cu&aacute;rtica.
</p>
<p>En caso de que <var>E</var> sea un polinomio respecto de una funci&oacute;n de la inc&oacute;gnita, por ejemplo <code>F(X)</code>, entonces se calcula primero para  <code>F(X)</code> (sea <var>C</var> el resultado obtenido), entonces la ecuaci&oacute;n <code>F(X)=C</code> se resuelve para <var>X</var> en el supuesto que se conozca la inversa de la funci&oacute;n <var>F</var>.
</p>
<p>Si la variable <code>breakup</code> vale <code>false</code> har&aacute; que <code>solve</code> muestre las soluciones de las ecuaciones c&uacute;bicas o cu&aacute;rticas como expresiones &uacute;nicas, en lugar de utilizar varias subexpresiones comunes, que es el formato por defecto.
</p>
<p>A la variable <code>multiplicities</code> se le asignar&aacute; una lista con las multiplicidades de las soluciones individuales devueltas por <code>solve</code>, <code>realroots</code> o <code>allroots</code>. La instrucci&oacute;n <code>apropos (solve)</code> har&aacute; que se muestren las variables optativas que de alg&uacute;n modo afectan al comportamiento de <code>solve</code>. Se podr&aacute; luego utilizar la funci&oacute;n  <code>describe</code> para aquellas variables cuyo objeto no est&eacute; claro.
</p>
<p>La llamada <code>solve ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_n</var>])</code>
resuelve un sistema de ecuaciones polin&oacute;micas simult&aacute;neas (lineales o no) llamando a <code>linsolve</code> o <code>algsys</code> y devuelve una lista de listas con soluciones para las inc&oacute;gnitas. En caso de haberse llamado a <code>linsolve</code> esta lista contendr&aacute; una &uacute;nica lista de soluciones. La llamada a <code>solve</code> tiene dos listas como argumentos. La primera lista tiene las ecuaciones a resolver y la segunda son las inc&oacute;gnitas cuyos valores se quieren calcular. Si el n&uacute;mero de variables en las ecuaciones es igual al n&uacute;mero de inc&oacute;gnitas, el segundo argumento puede omitirse. En caso de sistemas lineales incompatibles se mostrar&aacute; el mensaje <code>inconsistent</code> (v&eacute;ase la variable <code>solve_inconsistent_error</code>); si no existe una &uacute;nica soluci&oacute;n, se mostrar&aacute; el mensaje <code>singular</code>.
</p>
<p>Si <code>programmode</code> vale <code>false</code>,
<code>solve</code> muestra la soluci&oacute;n con etiquetas de expresiones 
intermedias (<code>%t</code>) y devuelve las lista de etiquetas.
</p>

<p>Si <code>globalsolve</code> vale <code>true</code> y el problema consiste en resolver un sistema de dos o m&aacute;s ecuaciones lineales, a cada inc&oacute;gnita se le asigna el valor encontrado en la resoluci&oacute;n del sistema.
</p>
<p>Ejemplos:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE is using arc-trig functions to get a solution.
Some solutions will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
(%i6) solve (x^3 - 1);
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solvedecomposes</b>
<a name="IDX673"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>solvedecomposes</code> vale <code>true</code>, <code>solve</code> llama a <code>polydecomp</code> en caso de que se le pida resolver ecuaciones polin&oacute;micas.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solveexplicit</b>
<a name="IDX674"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>solveexplicit</code> vale <code>true</code>, le inhibe a <code>solve</code> devolver soluciones impl&iacute;citas, esto es, soluciones de la forma <code>F(x) = 0</code>, donde <code>F</code> es cierta funci&oacute;n.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solvefactors</b>
<a name="IDX675"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>solvefactors</code> vale <code>false</code>, <code>solve</code> no intenta factorizar la expresi&oacute;n.  Este valor <code>false</code> puede ser &uacute;til en algunos casos en los que la factorizaci&oacute;n no es necesaria.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solvenullwarn</b>
<a name="IDX676"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>solvenullwarn</code> vale <code>true</code>,  <code>solve</code> muestra un mensaje de aviso si es llamado con una lista de ecuaciones vac&iacute;a o con una lista de inc&oacute;gnitas vac&iacute;a. Por ejemplo, <code>solve ([], [])</code> imprimir&aacute; dos mensajes de aviso y devolver&aacute; <code>[]</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solveradcan</b>
<a name="IDX677"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>solveradcan</code> vale <code>true</code>, <code>solve</code> llama a <code>radcan</code>, lo que har&aacute; que <code>solve</code> se ejecute de forma m&aacute;s lenta, pero permitir&aacute; que se resuelvan ciertas ecuaciones que contengan exponenciales y logaritmos.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solvetrigwarn</b>
<a name="IDX678"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>solvetrigwarn</code> vale <code>true</code>, <code>solve</code> puede presentar un mensaje diciendo que est&aacute; utilizando funciones trigonom&eacute;tricas inversas para resolver la ecuaci&oacute;n, y que por lo tanto puede estar ignorando algunas soluciones.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solve_inconsistent_error</b>
<a name="IDX679"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>solve_inconsistent_error</code> vale <code>true</code>, <code>solve</code> y
<code>linsolve</code> devuelven un error si las ecuaciones a resolver son incompatibles. Si vale <code>false</code>, <code>solve</code> y <code>linsolve</code> devuelven la lista vac&iacute;a <code>[]</code> en caso de incompatibilidad.
</p>
<p>Ejemplo:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) solve_inconsistent_error: true$
(%i2) solve ([a + b = 1, a + b = 2], [a, b]);
Inconsistent equations:  (2)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i3) solve_inconsistent_error: false$
(%i4) solve ([a + b = 1, a + b = 2], [a, b]);
(%o4)                          []
</pre></td></tr></table>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC69" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC71" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_74.html#SEC268" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>mayo, 2 2007</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
